{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"标题","date":"2022-06-20T11:30:37.378Z","updated":"2022-06-20T11:30:37.378Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"学生"}],"posts":[{"title":"非线性优化","slug":"最优化算法","date":"2022-09-06T09:19:49.897Z","updated":"2022-09-06T09:21:58.395Z","comments":true,"path":"2022/09/06/最优化算法/","link":"","permalink":"http://example.com/2022/09/06/%E6%9C%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95/","excerpt":"","text":"Hessian矩阵 梯度下降法——古老，不具有实用性 梯度下降缺点梯度法短视，容易出现锯齿状，迭代难收敛。（初始值敏感）2.步长选取——容易振荡不收敛 牛顿法——避免锯齿状迭代两点一阶导数相同，但是红点二阶导数大，所以步长小蓝点二阶导数小，步长大 缺点：海森矩阵计算量大 高斯-牛顿函数 LM方法阻尼牛顿法 一阶泰勒没法近似 对与 μ&gt;0 ， (H+μI) 正定，保证了 h 是梯度下降的方向。 当 μ 较大时： h≈−1μg&#x3D;−1μF′(x) ，其实就是梯度、最速下降法，当离最终结果较远的时候，很好。 当** μ 较小时，方法接近与高斯牛顿，当离最终结果很近时，可以获得二次收敛速度**，很好LM算法是介于牛顿法与梯度下降法之间的一种非线性优化方法，对于过参数化问题不敏感，能有效处理冗余参数问题，使代价函数陷入局部极小值的机会大大减小，这些特性使得LM算法在计算机视觉等领域得到广泛应用。","categories":[],"tags":[{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"牛客论坛项目","slug":"牛客论坛项目仿写","date":"2022-07-30T06:56:15.826Z","updated":"2022-07-30T06:58:11.577Z","comments":true,"path":"2022/07/30/牛客论坛项目仿写/","link":"","permalink":"http://example.com/2022/07/30/%E7%89%9B%E5%AE%A2%E8%AE%BA%E5%9D%9B%E9%A1%B9%E7%9B%AE%E4%BB%BF%E5%86%99/","excerpt":"","text":"项目简介这个项目的整体结构来源于牛客网，主要使用了Springboot、Mybatis、MySQL、Redis、Kafka、等工具。主要实现了用户的注册、登录、发帖、点赞、系统通知、按热度排序、搜索等功能。另外引入了redis数据库来提升网站的整体性能，实现了用户凭证的存取、点赞关注的功能。基于 Kafka 实现了系统通知：当用户获得点赞、评论后得到通知。利用定时任务定期计算帖子的分数，并在页面上展现热帖排行榜。 用户表实现 id username password salt email type status activation_code header_url cre 私信表的实现 id form_id to_id conversion_id content status create_time 评论表的实现： id user_id entity_type entity_id target_id content status create_time 密码MD5(Message-digestAlgorithm5)加密为了保证安全，密码不能明文的在网络中进行传输，也不能以明文的形式存到数据库中。存在数据库的密码 &#x3D; MD5( 密码 + salt ) 防止密码泄露 MD5加密 MD5算法为计算机安全领域广泛使用的一种散列函数，用于提供消息的完整性，是计算机广泛使用的哈希算法之一 MD5的固定长度为128比特，16字节，通常用他的16进制字面值输出他，是一个长度为32位的字符串。 会话管理（分布式Session问题）由于Http是无状态的，每次的http请求之间信息不共享，为了保证用户每次请求不用重新输入账号密码，保存用户的登录状态，就会有session和cookie这样的机制，去保存用户登录信息，但是在分布式部署的时候就会存在session共享的一个问题。 由于现在网站基本是多台服务器分布式部署的，如果将用户信息存到session中，而session是存到服务器上，在分布式环境下，由于各个服务器主机之间的信息并不共享，将用户信息存到服务器1上，同一个用户的下一个请求过来的时候，由于nginx的负载均衡策略，去请求了服务器2，就找不到之前的session了。下面介绍几种分布式Session问题的解决策略。 粘性session：同一个ip分给同一个服务器，很难做负载均衡 同步Session：当一个服务器创建了session之后，会将该Session同步给其他服务器。服务器之间耦合，加大服务器之间的同步开销 Session服务器：专门一个服务器管理Session，这台服务器是单体的，万一挂掉，有安全隐患 将客户端会话数据不存到Session中而是存到数据库中：关系型数据库性能较慢存到redis中（项目中采用的方式） Spring aop记录日志aop实现对service层所有的业务方法记录日志 Aop是一种编程思想，是对OOP的补充，可以进一步提升效率 Aop解决纵向切面的问题，主要实现日志和权限控制的功能 aspect实现切面，并且使用Logger来记录日志。用该切面的切面方法来监听controller 拦截器主要针对的是控制层controller 使用Redis实现点赞关注点赞和关注从功能上来说用传统的关系型数据库实现，但是其关系性并非很强，而且也是非常频繁的操作，用简单快速的Nosql也可以实现。 点赞功能 支持对帖子、评论点赞 第一次点赞，第2次取消点赞(判断userId在不在set集合中，就可以判断用户有否点过赞，如果已经点过赞了，就将用户从集合中删除) 在查询某人对某实体的点赞状态时，用可以用boolean作为返回值，但项目中使用int（支持业务扩展，可以支持是否点踩） Key Value like:entity:entityType:entityId set(userId) value使用set集合存放userId是为了能看对谁点了赞。 我收到的赞：点赞时同样需要记录点赞实体的用户id 某个用户收到的赞 Key Value like:user:userId int 关注、取消关注功能使用Redis实现了每一个用户的粉丝列表，以及每一个用户的关注列表。 由于关注成功以及添加粉丝成功需要在同一个事务中，Redis的事务主要是由multi与exec两个命令实现。 关键点： A关注了B，则A是B的Follwer，B是A的Followee(目标） 关注的目标，可是用户、帖子、题目，在是现实将这些目标抽象为实体 某个用户关注的实体 Key Value followee:userId:entityType zset(entityId,now) 使用zset以当前时间作为分数排序 某个实体拥有的粉丝 Key Value follower:entityType:entityId zset(userId,now) Kafka，实现异步消息系统在项目中，会有一些不需要实时执行但是是非常频繁的操作或者任务，为了提升网站的性能，可以使用异步消息的形式进行发送，再次消息队列服务器kafka来实现。kafka的具体配置与使用可参考下文： mac下消息队列服务器kafka（结合springboot）的配置与使用 发送系统通知评论，点赞，关注等事件是非常频繁的操作，发送关系其的系统通知却并不是需要立刻执行的。主要实现分为下面几步： 触发事件 评论后，发布通知 点赞后，发布通知 关注后，发布通知 处理事件 封装事件对象（Event） 12345private String topic;private int userId;private int entityType;private int entityUserId;private Map&lt;String,object&gt; data; 开发事件的生产者 向特定的主题（评论，点赞，关注）发送事件 12345 //处理事件(发送事件)public void fireEvent(Event event)&#123; //将事件发布到指定的主题 kafkaTemplate.send(event.getTopic(), JSONObject.toJSONString(event));&#125; 开发事件的消费者 使用@KafkaListener注解监听事件，如果监听成果并进行相应的处理，最后调用messageService添加到数据库中，下次用户显示消息列表的时候就可以看到系统消息了。 1234567891011121314151617@KafkaListener(topics = &#123;TOPIC_COMMENT, TOPIC_LIKE, TOPIC_FOLLOW&#125;) public void handleCommentMessage(ConsumerRecord record) &#123; Event event = JSONObject.parseObject(record.value().toString(), Event.class); //发送站内的通知 Message message = new Message(); message.setFromId(SYSTEM_USER_ID); message.setToId(event.getEntityUserId()); message.setConversationId(event.getTopic());//comment like follow message.setCreateTime(new Date()); message.setContent(JSONObject.toJSONString(content)); System.out.println(content); //调用messageService添加到数据库中 messageService.addMessage(message); &#125;","categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://example.com/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"}]},{"title":"Hashmap源码","slug":"Java基础","date":"2022-07-14T16:36:19.692Z","updated":"2022-07-29T00:35:19.728Z","comments":true,"path":"2022/07/15/Java基础/","link":"","permalink":"http://example.com/2022/07/15/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"HashMap源码参数「键值对数量」在 HashMap 中，使用 size 来表示 HashMap 中键值对的数量。「扩容阈值」在 HashMap 中，使用 threshold 表示扩容的阈值，也就是 初始容量 * 负载因子的值。size&gt;threshold，resize() jdk1.7和jdk1.8的区别 数据结构：首先是最重要的就是底层的数据结构，1.7的时候底层数据结构是数组+链表；而在1.8的时候变成了数组+链表+红黑树 Hash(key)的计算方式不同：在哈希上1.7扰动四次，1.8做了一次扰动（key.hashCode()) ^ (h &gt;&gt;&gt; 16)），扰动四次边际效用收益不大 扩容后数存储位置的计算方式不同：1.7在进行resize扩容的时候是重新哈希，1.8的时候采用的是索引位置不变或者就是就哈希表（oldCap)的容量+当前索引。(分成两个链表处理，详见resize()) 链表的插入方式不同：1.7采用插入方式是头插法，1.8采用的是尾插法。 在插入时，1.7 先判断是否需要扩容，再插入，1.8 先进行插入，插入完成再判断是否需要扩容。 扩容 1.8 不用重新 hash 就可以直接定位原节点在新数据的位置呢？这是由于扩容是扩大为原数组大小的 2 倍，用于计算数组位置的掩码仅仅只是高位多了一个 1，举个例子：扩容前长度为 16，用于计算 (n-1) &amp; hash 的二进制 n - 1 为 0000 1111，扩容后为 32 后的二进制就高位多了 1，&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;为 0001 1111。因为是 &amp; 运算，1 和任何数 &amp; 都是它本身，那就分二种情况，如下图：原数据 hashcode 高位第 4 位为 0 和高位为 1 的情况；第四位高位为 0，重新 hash 数值不变，第四位为 1，重新 hash 数值比原来大 16（旧数组的容量）。 1.7头插法多线程扩容，可能导致循环因为 1.7 头插法扩容时，头插法会使链表发生反转，多线程环境下会产生环；A 线程在插入节点 B，B 线程也在插入，遇到容量不够开始扩容，重新 hash，放置元素，采用头插法，后遍历到的 B 节点放入了头部，这样形成了环，如下图所示： 构造函数中tableSizeFor()保证传入的容量匹配到大于cap的2的n次方 1234567891011static final int tableSizeFor(int cap) &#123; //最左边的一不断右移，并异或；使最左边的1的后面全部都变成1 //cap-1,避免cap=1&lt;&lt;30，MAXIMUM_CAPACITY时，不减一最后n+1溢出 int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 12345678//不减一 n=cap01 00000 00000 00000 00000 00000 00000 (n) 01 10000 00000 00000 00000 00000 00000 (n |= n &gt;&gt;&gt; 1) 01 11100 00000 00000 00000 00000 00000 (n |= n &gt;&gt;&gt; 2) 01 11111 11000 00000 00000 00000 00000 (n |= n &gt;&gt;&gt; 4) 01 11111 11111 11111 00000 00000 00000 (n |= n &gt;&gt;&gt; 8) 01 11111 11111 11111 11111 11111 11111 (n |= n &gt;&gt;&gt; 16) //n+1,溢出为负数 put()方法 hash()函数中异或处理，高16位与低16位异或，这样i &#x3D; (n - 1) &amp; hash（取低位）时，可以减小哈希冲突的概率。这样可以尽量保留高16位的特征，就算两个hashCode()返回值，低16位高度相同，异或后h的haminton距离也会较大。为什么使用异或？减小哈希碰撞 HashMap 是线程安全的吗？ 不是，在多线程环境下，1.7 会产生死循环、数据丢失、数据覆盖的问题，1.8 中会有数据覆盖的问题。以 1.8 为例，当 A 线程执行到下面代码第 6 行判断 index 位置为空后正好挂起，B 线程开始执行第 7 行，往 index 位置的写入节点数据，这时 A 线程恢复现场，执行赋值操作，就把 A 线程的数据给覆盖了。还有第 38 行 ++size 这个地方也会造成多线程同时扩容等问题。 123456789101112131415161718192021222324252627282930313233343536373839404142final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) //多线程执行到这里 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) // 多个线程走到这，可能重复resize() resize(); afterNodeInsertion(evict); return null;&#125; 怎么解决这个线程不安全的问题？ Java 中有 HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap 可以实现线程安全的Map。 HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个数组，粒度比较大； Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现； ConcurrentHashMap 使用分段锁，降低了锁粒度，让并发度大大提高。 resize()方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//将集合扩容 final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; //旧表的容量 int oldCap = (oldTab == null) ? 0 : oldTab.length; //之前的阈值 int oldThr = threshold; int newCap, newThr = 0; //这里也可以说集合不为空 if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//如果集合现在数组的长度大于等于最大容量 threshold = Integer.MAX_VALUE;//将整型最大的值赋值给threshold return oldTab; &#125; //当前集合数组长度扩大二倍赋值给newCap小于MAXIMUM_CAPACITY //并且集合的容量大于等于默认容量将当前阈值扩大二倍赋值给新的阈值 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; //若没有经历过初始化，通过构造函数指定了initialCapcity，将当前容量设置为大于它最小的2的n次方 else if (oldThr &gt; 0) newCap = oldThr; else &#123; // 初始的时候长度和阈值都使用默认值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //重新计算threshold if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //更新当前集合阈值 threshold = newThr; //从这里开始便是将oldTab数据重新hash放入扩容后的newTab @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //将table指向的oldTab指向newTab table = newTab; if (oldTab != null) &#123; //遍历哈希表 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; //当前链表是否为null、并且将就链表赋值给e if ((e = oldTab[j]) != null) &#123; oldTab[j] = null;//将原来位置的链表置为null方便垃圾回收 if (e.next == null)//链表的长度为1直接将链表中的一个节点重新hash存放到相应的位置 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) //表示节点类型为树形结构 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; //链表是非树形结构，并且节点数量是大于1 //将链表拆分为两个子链表 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; //通过do...while遍历链表 next = e.next; //e.hash &amp; oldCap 看这一位是1是0，分成两个链表处理 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) //设置头节点 loHead = e; else //设置尾结点 loTail.next = e; loTail = e;//将尾结点变为最后一个节点 &#125; else &#123; if (hiTail == null)//同上都是设置头节点下面也一样是设置尾结点 hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123;//在新表的j位置存放链表 loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123;//在新表的j+oldCap位置存放链表 hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; LinkedHashMap 怎么实现有序的？LinkedHashMap 内部维护了一个双向链表，有头尾节点，同时 LinkedHashMap 节点** Entry类 **内部除了继承 HashMap 的 Node 属性，还有 before 和 after 用于标识前置节点和后置节点。可以实现按插入的顺序或访问顺序排序。 TreeMap 怎么实现有序的？TreeMap实现 SortMap 接口， 按照 Key 的自然顺序或者 Comprator 的顺序进行排序，内部是通过红黑树来实现。所以要么 key 所属的类实现 Comparable 接口，或者自定义一个实现了 Comparator 接口的比较器，传给 TreeMap 用户 key 的比较。 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。推荐：面试问红黑树，我脸都绿了。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡(自平衡树），引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。 ConcurrentHashMap在 JDK 1.7 中采用 分段锁的方式；JDK 1.8 中直接采用了CAS（无锁算法）+ synchronizedHashMap 的键值对允许有null，但是ConCurrentHashMap 都不允许。 JDK 1.7 中，采用分段锁的机制，实现并发的更新操作，底层采用数组+链表的存储结构，包括两个核心静态内部类 Segment 和 HashEntry。①、Segment 继承 ReentrantLock（重入锁） 用来充当锁的角色，每个 Segment 对象守护每个散列映射表的若干个桶；②、HashEntry 用来封装映射表的键-值对；③、每个桶是由若干个 HashEntry 对象链接起来的链表 JDK 1.8 中，采用Node + CAS + Synchronized来保证并发安全。取消类 Segment，直接用 table 数组存储键值对；当 HashEntry 对象组成的链表长度超过 TREEIFY_THRESHOLD 时，链表转换为红黑树，提升性能。底层变更为数组 + 链表 + 红黑树。 存储对象时（put() 方法）：：如果没有初始化，就调用 initTable() 方法来进行初始化；如果没有 hash 冲突就**直接 CAS **无锁插入；如果需要扩容，就先进行扩容；如果存在 hash 冲突，就加锁来保证线程安全，两种情况：一种是链表形式就直接遍历到尾端插入，一种是红黑树就按照红黑树结构插入；如果该链表的数量大于阀值 8，就要先转换成红黑树的结构，break 再一次进入循环如果添加成功就调用 addCount() 方法统计 size，并且检查是否需要扩容。 ConcurrentHashMap 在 JDK 1.8 中，为什么要使用内置锁 synchronized 来代替重入锁 ReentrantLock？①、粒度降低了；②、JVM 开发团队没有放弃 synchronized，而且基于 JVM 的 synchronized 优化空间更大，更加自然。③、在大量的数据操作下，对于 JVM 的内存压力，基于 API 的 ReentrantLock 会开销更多的内存。 ConcurrentHashMap 的并发度是什么？程序运行时能够同时更新 ConccurentHashMap 且不产生锁竞争的最大线程数。默认为 16，且可以在构造函数中设置。当用户设置并发度时，ConcurrentHashMap 会使用大于等于该值的最小2幂指数作为实际并发度（假如用户设置并发度为17，实际并发度则为32） 解决哈希冲突的方法 开放定址优点 易序列化 若可预知数据总数，可以创建完美哈希数列 缺点 占空间很大。（开放定址法为减少冲突，要求装填因子α较小，故当结点规模较大时会浪费很多空间） 删除节点很麻烦。不能简单地将被删结点的空间置为空，否则将截断在它之后填人散列表的同义词结点的查找路径。这是因为各种开放地址法中，空地址单元(即开放地址)都是查找失败的条件。因此在用开放地址法处理冲突的散列表上执行删除操作，只能在被删结点上做删除标记，而不能真正删除结点。 123//d可取线性，二次，随机数(hash(key) + d) % table.length;d = 1^2, -1^2, 2^2, -2^2, 3^2...... 深拷贝和浅拷贝区别了解吗？什么是引用拷贝浅拷贝会在堆上复制一个新的对象，但是，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。（只复制引用，而不复制对象本身，新旧对象还是共享同一块内存）。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。引用拷贝就是两个不同的引用指向同一个对象，直接赋值。 Java异常Checked Exception 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 catch或者throws 关键字处理的话，就没办法通过编译。Unchecked Exception 即 不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。RuntimeException 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到)： NullPointerException(空指针错误) IllegalArgumentException(参数错误比如方法入参类型错误) NumberFormatException（字符串转换为数字格式错误，IllegalArgumentException的子类） ArrayIndexOutOfBoundsException（数组越界错误） ClassCastException（类型转换错误） ArithmeticException（算术错误） SecurityException （安全错误比如权限不够） UnsupportedOperationException(不支持的操作错误比如重复创建同一用户)","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java基础笔记","slug":"Java基础笔记","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"}]},{"title":"剑指 Offer30. 包含min函数的栈","slug":"30实现min函数的栈","date":"2022-07-14T16:31:14.046Z","updated":"2022-07-30T06:58:44.218Z","comments":true,"path":"2022/07/15/30实现min函数的栈/","link":"","permalink":"http://example.com/2022/07/15/30%E5%AE%9E%E7%8E%B0min%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","excerpt":"","text":"剑指 Offer 30. 包含min函数的栈难度简单345 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 示例: 12345678MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.min(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.min(); --&gt; 返回 -2. 辅助栈 同步维护一个状态，每push一个值，最小栈也要push一个当前最小值（维护一个状态）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class MinStack &#123; Stack&lt;Integer&gt; st; Stack&lt;Integer&gt; minState; /** initialize your data structure here. */ public MinStack() &#123; st=new Stack&lt;&gt;(); minState=new Stack&lt;&gt;(); &#125; public void push(int x) &#123; st.push(x); if(minState.size()==0 || x &lt; minState.peek())&#123; minState.push(x); &#125;else&#123; minState.push(minState.peek()); &#125; &#125; public void pop() &#123; if(!st.isEmpty() &amp;&amp; !minState.isEmpty())&#123; st.pop(); minState.pop(); &#125; &#125; public int top() &#123; if(!st.isEmpty())&#123; return st.peek(); &#125; return -1; &#125; public int min() &#123; if(!minState.isEmpty())&#123; return minState.peek(); &#125; return -1; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"}]},{"title":"剑指 Offer 29. 顺时针打印矩阵","slug":"29 顺时针打印矩阵","date":"2022-07-14T16:31:14.043Z","updated":"2022-07-14T16:30:01.537Z","comments":true,"path":"2022/07/15/29 顺时针打印矩阵/","link":"","permalink":"http://example.com/2022/07/15/29%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","excerpt":"","text":"剑指 Offer 29. 顺时针打印矩阵难度简单412 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 示例 2： 12输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; int[] res; int index=0; public int[] spiralOrder(int[][] matrix) &#123; if(matrix==null || matrix.length==0 ||matrix[0].length==0)&#123; return new int[]&#123;&#125;; &#125; int m=matrix.length; int n=matrix[0].length; res=new int[m*n]; int startPoint=0; //循环一圈（start=1），m和n减少start*2,作为是否还有格子剩下没打印的判断条件 while(m&gt;startPoint*2 &amp;&amp; n&gt;startPoint*2)&#123; printCircle(matrix,startPoint,m,n); startPoint++; &#125; return res; &#125; private void printCircle(int[][] matrix, int startPoint, int m, int n) &#123; //边界条件更改 int endX=m-1-startPoint; int endY=n-1-startPoint; //从左到右，这个如果进入，肯定会执行，因为至少有一个剩下了 for (int i = startPoint; i &lt;=endY ; i++) &#123; res[index++]=matrix[startPoint][i]; &#125; //右边界，看有几行 for (int i = startPoint+1; i &lt;=endX ; i++) &#123; res[index++]=matrix[i][endY]; &#125; //下边界，也要看有几行，终止行号必须大于起始行号 //但是循环的是列 for (int i = endY-1; (startPoint&lt;endX) &amp;&amp; (i &gt;=startPoint); i--) &#123; res[index++]=matrix[endX][i]; &#125; //左边界，终止列号必须大于起始列号 //但是控制循环的条件是行号 for (int i = endX-1; (startPoint&lt;endY) &amp;&amp;(i &gt;startPoint) ; i--) &#123; res[index++]=matrix[i][startPoint]; &#125; &#125;&#125;","categories":[],"tags":[{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"}]},{"title":"剑指 Offer 20. 表示数值的字符串","slug":"20 字符串分解为字符","date":"2022-07-14T16:31:14.039Z","updated":"2022-07-14T16:31:02.009Z","comments":true,"path":"2022/07/15/20 字符串分解为字符/","link":"","permalink":"http://example.com/2022/07/15/20%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E8%A7%A3%E4%B8%BA%E5%AD%97%E7%AC%A6/","excerpt":"","text":"剑指 Offer 20. 表示数值的字符串难度中等341 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。 数值（按顺序）可以分成以下几个部分： 若干空格——子函数space() 一个 小数 或者 整数 （可选）一个 &#39;e&#39; 或 &#39;E&#39; ，后面跟着一个 整数 若干空格 小数（按顺序）可以分成以下几个部分： （可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;）—子函数unsignedInteger() 下述格式之一： 至少一位数字，后面跟着一个点 &#39;.&#39; 至少一位数字，后面跟着一个点 &#39;.&#39; ，后面再跟着至少一位数字 一个点 &#39;.&#39; ，后面跟着至少一位数字 整数（按顺序）可以分成以下几个部分： （可选）一个符号字符（&#39;+&#39; 或 &#39;-&#39;） 至少一位数字 部分数值列举如下： [&quot;+100&quot;, &quot;5e2&quot;, &quot;-123&quot;, &quot;3.1416&quot;, &quot;-1E-16&quot;, &quot;0123&quot;] 部分非数值列举如下： [&quot;12e&quot;, &quot;1a3.14&quot;, &quot;1.2.3&quot;, &quot;+-5&quot;, &quot;12e+5.4&quot;] 示例 1： 12输入：s = &quot;0&quot;输出：true 示例 2： 12输入：s = &quot;e&quot;输出：false 示例 3： 12输入：s = &quot;.&quot;输出：false 示例 4： 12输入：s = &quot; .1 &quot;输出：true 提示： 1 &lt;= s.length &lt;= 20 s 仅含英文字母（大写和小写），数字（0-9），加号 &#39;+&#39; ，减号 &#39;-&#39; ，空格 &#39; &#39; 或者点 &#39;.&#39; 。 数值可以拆分为三个部分： 整数部分A，小数部分B，指数部分C(1e-16,1e16)。 先扫描A，再扫描B, 再扫描C。返回组合的条件。（B||A , (B||A)&amp;&amp;C） 特殊的处理只包括 “.”和‘e’ , 模式最基础的部分是整数的扫描，分别为带符号的整数(A,C) 和不带符号的整数（B）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; private int i; public boolean isNumber(String s) &#123; if(s==null)&#123; return false; &#125; i=0; //空格处理 space(s); //处理带符号整数 boolean num=isInteger(s); //扫描完小数 if (i&lt; s.length() &amp;&amp;s.charAt(i) == &#x27;.&#x27;) &#123; i++; //条件为或，可以不存在带符号整数（.12）,小数点后可以没有无符号整数（12.） //isUsignedInteger要写在前面，防止被短路，i没有扫描到最后一位 num = isUsignedInteger(s)||num; &#125; //不能用else if，因为e前面也有可能是小数（46.e3） //处理指数部分 //带符号整数 + e + 无符号整数 if (i&lt; s.length() &amp;&amp;s.charAt(i) == &#x27;e&#x27; || s.charAt(i) == &#x27;E&#x27;) &#123; i++; num = num &amp;&amp; isInteger(s); &#125; space(s); return num &amp;&amp; i == s.length(); &#125; private void space(String s) &#123; while(i&lt; s.length() &amp;&amp; s.charAt(i)==&#x27; &#x27;)&#123; i++; &#125; &#125; private boolean isInteger(String s) &#123; if(i&lt; s.length()&amp;&amp; (s.charAt(i)==&#x27;+&#x27; || s.charAt(i)==&#x27;-&#x27;))&#123; i++; &#125; return isUsignedInteger(s); &#125; /** * 至少一位整数数字 * @param s * @return */ private boolean isUsignedInteger(String s) &#123; int tmp=i; while(i&lt;s.length() &amp;&amp; (s.charAt(i)&lt;=&#x27;9&#x27;) &amp;&amp; (s.charAt(i)&gt;=&#x27;0&#x27;))&#123; i++; &#125; return i&gt;tmp; &#125;&#125;","categories":[],"tags":[{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"}]},{"title":"剑指 Offer 19. 正则表达式匹配","slug":"19 正则表达式匹配","date":"2022-07-14T16:31:14.037Z","updated":"2022-07-30T06:57:11.209Z","comments":true,"path":"2022/07/15/19 正则表达式匹配/","link":"","permalink":"http://example.com/2022/07/15/19%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","excerpt":"","text":"剑指 Offer 19. 正则表达式匹配难度困难404 请实现一个函数用来匹配包含&#39;. &#39;和&#39;*&#39;的正则表达式。模式中的字符&#39;.&#39;表示任意一个字符，而&#39;*&#39;表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配。 示例 1: 12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 思路：动态规划 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 动态规划，依赖于子问题的解决 * 使用正则表达式 p 消耗字符串 s * 当 p是 “*”时，三种情况 * 1.(匹配）消耗0个字符,j损失两个 (i-0,j-2) dp[i][j]=dp[i][j-2] * 2.消耗1个字符，j不变(*可以留下来多消耗0个或者几个字符） (i-1,j) dp[i][j]=dp[i-1][j] &amp;&amp; s.charAt(i-1)==p.charAt(j-2) * 3.消耗一个字符，j不变 dp[i][j]=dp[i-1][j]&amp;&amp;p.charAt(j-2)==&#x27;.&#x27; * * 当p不是“*”时，两种情况 * @author huzhifei */class Solution &#123; public boolean isMatch(String s, String p) &#123; int m=s.length(); int n=p.length(); boolean[][] dp=new boolean[m+1][n+1]; //初始化，s的长度为0的情况 dp[0][0]=true; //s没有字符可以消耗，使用于 情况一才会有，true出现（从0开始，j取偶数，有true的可能） for (int j = 2; j &lt;=n ; j+=2) &#123; dp[0][j]=dp[0][j-2]&amp;&amp;p.charAt(j-1)==&#x27;*&#x27;; &#125; for (int i = 1; i &lt;m+1 ; i++) &#123; for (int j = 1; j &lt;n+1 ; j++) &#123; if(p.charAt(j-1)==&#x27;*&#x27;)&#123; dp[i][j]=dp[i][j-2]||(s.charAt(i-1)==p.charAt(j-2)&amp;&amp; dp[i-1][j]) || (dp[i-1][j]&amp;&amp;p.charAt(j-2)==&#x27;.&#x27;); &#125;else&#123; dp[i][j]=(s.charAt(i-1)==p.charAt(j-1) &amp;&amp; dp[i-1][j-1]) ||(dp[i-1][j-1] &amp;&amp; p.charAt(j-1)==&#x27;.&#x27;); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"}]},{"title":"剑指 Offer 17. 打印从1到最大的n位数","slug":"17 打印从1到最大的n位数","date":"2022-07-14T16:31:14.032Z","updated":"2022-07-14T16:28:20.254Z","comments":true,"path":"2022/07/15/17 打印从1到最大的n位数/","link":"","permalink":"http://example.com/2022/07/15/17%20%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/","excerpt":"","text":"剑指 Offer 17. 打印从1到最大的n位数难度简单227 输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 示例 1: 12输入: n = 1输出: [1,2,3,4,5,6,7,8,9] 说明： 用返回一个整数列表来代替打印 n 为正整数 考虑大数问题，使用字符串模拟，并转换为全排列问题 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; List&lt;String&gt; res; StringBuilder cur; char[] NUM = &#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;&#125;; public int[] printNumbers(int n) &#123; res = new ArrayList&lt;&gt;(); cur=new StringBuilder(); for (int i = 1; i &lt;= n; i++) &#123; dfs(0,i); &#125; return res.stream().mapToInt(a-&gt;Integer.parseInt(a)).toArray(); &#125; /** * 生成长度为len的字符串，0&lt;len&lt;=n * x为当前位数，x&lt;=len * x==0时(从左到右），num[i]从1开始循环 */ void dfs(int x,int len) &#123; if(x == len) &#123; res.add(cur.toString()); return; &#125; // X=0表示左边第一位数字，不能为0 int start = x==0? 1 : 0; for(int i=start; i&lt;10; i++) &#123; // 确定本位数字 cur.append(NUM[i]); // 确定下一位数字 dfs(x+1, len); // 删除本位数字 cur.deleteCharAt(cur.length()-1); &#125; &#125;&#125;","categories":[],"tags":[{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"}]},{"title":"剑指 Offer 16. 数值的整数次方","slug":"16 数值的整数次方","date":"2022-07-14T16:31:14.026Z","updated":"2022-07-29T00:33:03.183Z","comments":true,"path":"2022/07/15/16 数值的整数次方/","link":"","permalink":"http://example.com/2022/07/15/16%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/","excerpt":"","text":"剑指 Offer 16. 数值的整数次方难度中等303 实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，xn）。不得使用库函数，同时不需要考虑大数问题。 示例 1： 12输入：x = 2.00000, n = 10输出：1024.00000 示例 2： 12输入：x = 2.10000, n = 3输出：9.26100 示例 3： 123输入：x = 2.00000, n = -2输出：0.25000解释：2-2 = 1/22 = 1/4 = 0.25 提示： -100.0 &lt; x &lt; 100.0 -231 &lt;= n &lt;= 231-1 -104 &lt;= xn &lt;= 104 递归： TC=SC=O(logn) 12345678910111213141516171819202122232425262728293031323334353637383940/** * Java 代码中 int32 变量 n∈[−2147483648,2147483647] ， * 因此当 n = -2147483648n=−2147483648 时执行 n = -n会因越界而赋值出错。 * 解决方法是先将 n 存入 long 变量 b ，后面用 b 操作即可。 * * */class Solution &#123; public double myPow(double x, int n) &#123; if(x==0)&#123; return 0.0; &#125; long b=n; if(b&lt;0)&#123; x=1/x; b=-b; &#125; return helper(x,b); &#125; private double helper(double x, long n) &#123; if(n==0)&#123; return 1; &#125; if(n==1)&#123; return x; &#125; double result=helper(x,n&gt;&gt;1); result*=result; if((n&amp;1)==1)&#123; result*=x; &#125; return result; &#125;&#125; 迭代： TC:O(logn) SC:O(1) 123456789101112131415161718192021222324252627282930313233/** * Java 代码中 int32 变量 n∈[−2147483648,2147483647] ， * 因此当 n = -2147483648n=−2147483648 时执行 n = -n会因越界而赋值出错。 * 解决方法是先将 n 存入 long 变量 b ，后面用 b 操作即可。 * * &#125; */class Solution &#123; public double myPow(double x, int n) &#123; if(x==0)&#123; return 0.0; &#125; long b=n; double ans=1; if(n&lt;0)&#123; x=1/x; b=-b; &#125; while(b&gt;0)&#123; if((b&amp;1)==1)&#123; ans*=x; &#125; //x^n==(x^2)^(n/2) x=x*x; b=b&gt;&gt;1; &#125; return ans; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"}]},{"title":"剑指 Offer 15. 二进制中1的个数","slug":"15 二进制1的个数","date":"2022-07-14T16:31:14.021Z","updated":"2022-07-29T00:32:51.131Z","comments":true,"path":"2022/07/15/15 二进制1的个数/","link":"","permalink":"http://example.com/2022/07/15/15%20%E4%BA%8C%E8%BF%9B%E5%88%B61%E7%9A%84%E4%B8%AA%E6%95%B0/","excerpt":"","text":"剑指 Offer 15. 二进制中1的个数难度简单250 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为 汉明重量).）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用 二进制补码 记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 示例 1： 123输入：n = 11 (控制台输入 00000000000000000000000000001011)输出：3解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#x27;1&#x27;。 示例 2： 123输入：n = 128 (控制台输入 00000000000000000000000010000000)输出：1解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#x27;1&#x27;。 示例 3： 123输入：n = 4294967293 (控制台输入 11111111111111111111111111111101，部分语言中 n = -3）输出：31解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#x27;1&#x27;。 TC:O(log2n)&lt;32 123456789101112131415public class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int ans=0; while(n!=0)&#123; ans+=n&amp;1; //逻辑右移，无符号右移 n=n&gt;&gt;&gt;1; &#125; return ans; &#125;&#125; TC:O(ans) 1234567891011121314151617181920/** * (n−1) 解析： 二进制数字 n 最右边的 1 变成 0 * n&amp;(n−1) 解析：消灭一个最右边的1 * eg. n=1110, n-1=1101,n(n-1)=1100,不涉及符号位，即左右移事项 * */ class Solution &#123; // you need to treat n as an unsigned value public int hammingWeight(int n) &#123; int ans=0; while(n!=0)&#123; ans++; n=n&amp;(n-1); &#125; return ans; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"}]},{"title":"剑指 Offer 14- I. 剪绳子","slug":"14 剪绳子","date":"2022-07-14T16:31:14.016Z","updated":"2022-07-29T00:32:39.890Z","comments":true,"path":"2022/07/15/14 剪绳子/","link":"","permalink":"http://example.com/2022/07/15/14%20%E5%89%AA%E7%BB%B3%E5%AD%90/","excerpt":"","text":"剑指 Offer 14- I. 剪绳子难度中等431 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 示例 1： 123输入: 2输出: 1解释: 2 = 1 + 1, 1 × 1 = 1 示例 2: 123输入: 10输出: 36解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 动态规划： 从上到下分析问题，f(n)问题分解为f(n-i)和f(i)问题（0&lt;i&lt;n)，这两个都取到最优解，则f(n)也是最优解； 从下到上解决问题，f(n),f(n-1)存在重复子问题，所以从下到上计算，并储存子问题答案 状态转移方程： f(n)=max(f(n-i)*f(i)) TC：O(n^2) SC：O(n) 123456789101112131415161718192021222324252627282930313233class Solution &#123; public int cuttingRope(int n) &#123; if(n==0)&#123; return 0; &#125; if(n==1 || n==2)&#123; return 1; &#125; if(n==3)&#123; return 2; &#125; int[] dp=new int[n+1]; //小于等于3的时候，不剪取到最大值 dp[1]=1; //2&gt;1 dp[2]=2; //3&gt;2 dp[3]=3; for (int i = 4; i &lt; n + 1; i++) &#123; for (int j = 1; j &lt;= i/2; j++) &#123; dp[i]=Math.max(dp[i],dp[i-j]*dp[j]); &#125; &#125; return dp[n]; &#125;&#125; 贪心： TC &amp; SC：O(1) 1234567891011121314151617181920212223242526272829/** * 贪心，每一步最优 */class Solution &#123; //当绳子大于等于5时 //3(n-3)&gt;n,2(n-2)&gt;n所以要剪 public int cuttingRope(int n) &#123; if(n==0)&#123; return 0; &#125; if(n==1 || n==2)&#123; return 1; &#125; if(n==3)&#123; return 2; &#125; int timeOf3=n/3; if(n%3==1)&#123; return (int) (Math.pow(3,timeOf3-1)*4); &#125;else if(n%3==2)&#123; return (int) (Math.pow(3,timeOf3)*2); &#125;else&#123; return (int) Math.pow(3,timeOf3); &#125; &#125;&#125; 贪心取余 123456789101112131415161718192021222324252627class Solution &#123; //4没必要分，2，3不可再分，结果会变小 //当绳子大于等于5时 //3(n-3)&gt;n,2(n-2)&gt;n所以要剪，且3(n-3)&gt;2(n-2)，2，3为不可切分的单元。 //如果n-3大于等于5,继续切分 public int cuttingRope(int n) &#123; if(n==0)&#123; return 0; &#125; if(n==1 || n==2)&#123; return 1; &#125; if(n==3)&#123; return 2; &#125; long res=1; //4没必要分，2，3不可再分，会变小 while (n&gt;4)&#123; res= (long) ((res*3)%(1e9+7)); n-=3; &#125; //n取&#123;4(余数为1的情况)，3，2&#125; return (int) (n*res%(1e9+7)); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"}]},{"title":"剑指 Offer 12. 矩阵中的路径","slug":"12矩阵路径","date":"2022-07-14T16:31:14.011Z","updated":"2022-07-29T00:32:27.140Z","comments":true,"path":"2022/07/15/12矩阵路径/","link":"","permalink":"http://example.com/2022/07/15/12%E7%9F%A9%E9%98%B5%E8%B7%AF%E5%BE%84/","excerpt":"","text":"剑指 Offer 12. 矩阵中的路径难度中等593 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 例如，在下面的 3×4 的矩阵中包含单词 “ABCCED”（单词中的字母已标出）。 示例 1： 12输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;输出：true 示例 2： 12输入：board = [[&quot;a&quot;,&quot;b&quot;],[&quot;c&quot;,&quot;d&quot;]], word = &quot;abcd&quot;输出：false 和79题一样 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123; boolean[][] visited; boolean flag; int[] direction=new int[]&#123;-1,0,1,0,-1&#125;; public boolean exist(char[][] board, String word) &#123; visited=new boolean[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if(board[i][j]==word.charAt(0))&#123; dfs(board,word,0,i,j); &#125; &#125; &#125; return flag; &#125; private void dfs(char[][] board, String word, int level,int i,int j) &#123; //flag是必要剪枝条的一步，不然超时 //dfs搜索到之后在回溯的时候，剪枝 //因为dfs返回值为空，会搜索整颗树 if(level==word.length() || flag)&#123; flag=true; return; &#125; if(i&lt;0 || j&lt;0 || i&gt;=board.length || j&gt;=board[0].length || board[i][j]!=word.charAt(level) || visited[i][j])&#123; return; &#125; //第n个字符 visited[i][j]=true; //搜索n+1个字符 for (int k = 0; k &lt; 4; k++) &#123; int x=i+ direction[k]; int y=j+ direction[k+1]; dfs(board,word,level+1,x,y); &#125; //没有找到n+1个字符((n+1)没有被标记)，取消第n个字符，回退到n-1个字符 visited[i][j]=false; &#125;&#125; 修改版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; boolean[][] visited; // int[] direction=new int[]&#123;-1,0,1,0,-1&#125;; public boolean exist(char[][] board, String word) &#123; visited=new boolean[board.length][board[0].length]; for (int i = 0; i &lt; board.length; i++) &#123; for (int j = 0; j &lt; board[0].length; j++) &#123; if(dfs(board,word,0,i,j))&#123; return true; &#125; &#125; &#125; return false; &#125; private boolean dfs(char[][] board, String word, int level,int i,int j) &#123; if(level==word.length())&#123; return true; &#125; if(i&lt;0 || j&lt;0 || i&gt;=board.length || j&gt;=board[0].length || board[i][j]!=word.charAt(level) || visited[i][j])&#123; return false; &#125; visited[i][j]=true; for (int k = 0; k &lt; 4; k++) &#123; int x &#125; boolean flag=dfs(board,word,level+1,i+1,j)||dfs(board,word,level+1,i-1,j)|| dfs(board,word,level+1,i,j-1)|| dfs(board,word,level+1,i,j+1); if(!flag)&#123; visited[i][j]=false; &#125; return flag; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"}]},{"title":"剑指 Offer 03. 数组中重复的数字","slug":"03数组中重复的值","date":"2022-07-14T16:31:14.003Z","updated":"2022-07-14T16:26:29.356Z","comments":true,"path":"2022/07/15/03数组中重复的值/","link":"","permalink":"http://example.com/2022/07/15/03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%80%BC/","excerpt":"","text":"剑指 Offer 03. 数组中重复的数字难度简单838 找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 123输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 1234567891011121314151617181920212223242526272829303132/** * 原地哈希 * 数据在[0,n-1]之间，所以排序后，i==nums[i] * 把nums[i]放在i这个位置，如果出现哈希冲突就是重复的值 */class Solution &#123; public int findRepeatNumber(int[] nums) &#123; for (int i = 0; i &lt; nums.length; i++) &#123; //因为交换一次后有很大可能还是不等 nums[i] i //继续交换，i不能++ while (nums[i]!=i)&#123; //哈希冲突 if(nums[i]==nums[nums[i]])&#123; return nums[i]; &#125; swap(nums,i); &#125; &#125; return -1; &#125; private void swap(int[] nums, int i) &#123; int tmp=nums[i]; nums[i]=nums[nums[i]]; nums[nums[i]]=tmp; &#125;&#125;","categories":[],"tags":[{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"}]},{"title":"剑指 Offer 31. 栈的压入、弹出序列","slug":"31 出入栈模拟","date":"2022-07-14T16:31:13.998Z","updated":"2022-07-14T16:30:48.667Z","comments":true,"path":"2022/07/15/31 出入栈模拟/","link":"","permalink":"http://example.com/2022/07/15/31%20%E5%87%BA%E5%85%A5%E6%A0%88%E6%A8%A1%E6%8B%9F/","excerpt":"","text":"剑指 Offer 31. 栈的压入、弹出序列难度中等335 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 示例 1： 12345输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -&gt; 4,push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1 示例 2： 123输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。 提示： 0 &lt;= pushed.length == popped.length &lt;= 1000 0 &lt;= pushed[i], popped[i] &lt; 1000 pushed 是 popped 的排列。 思路：建立辅助栈模拟入栈和出栈过程 12345678910111213141516171819202122class Solution &#123; public boolean validateStackSequences(int[] pushed, int[] popped) &#123; ArrayDeque&lt;Integer&gt; st = new ArrayDeque&lt;&gt;(); int PopIndex =0; for(int num:pushed)&#123; //一直使用Pushed[]入栈，保持顺序 st.push(num); //st.peek()和Popped[i]相同，一直出栈 //不能写num,因为栈顶一直在变化 while(!st.isEmpty() &amp;&amp; st.peek()==popped[PopIndex] )&#123; st.pop(); PopIndex++; &#125; &#125; //栈为空，则说明按照popped[]可以实现 return st.isEmpty(); &#125;&#125;","categories":[],"tags":[{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"}]},{"title":"JVM总结","slug":"JVM","date":"2022-07-14T16:20:25.438Z","updated":"2022-07-29T00:35:38.423Z","comments":true,"path":"2022/07/15/JVM/","link":"","permalink":"http://example.com/2022/07/15/JVM/","excerpt":"","text":"自动内存管理线程共享区域：方法区和堆。方法区：1.8之前由永久代实现，1.8之后放入本地内存（物理内存中元空间），逻辑概念。为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢? 永久代有一个默认的大小，能够加载的类有限，容易OOＭ，也不太好调优。 在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。 堆： 对象 Stringtable, 类变量（static修饰静态变量）——1.7逐步去永久代，从方法区换到堆。 堆的大小可通过参数**-Xmx和-Xms**设定。线程私有：栈：一个方法对应一个栈帧。包含本地变量表，操作数栈，动态链接（指向运行时常量池)。 程序计数器： 对象的创建Java 对象的创建过程我建议最好是能默写出来，并且要掌握每一步在做什么。 #Step1:类加载检查一个类只加载一次，先检查当前类有没有被加载过。 #Step2:分配内存在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。内存分配的两种方式 （补充内容，需要掌握）： 指针碰撞 ： 适用场合 ：堆内存规整（即没有内存碎片）的情况下。 原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。 使用该分配方式的 GC 收集器：Serial, ParNew(新生代标记复制算法） 空闲列表 ： 适用场合 ： 堆内存不规整的情况下。 原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。 使用该分配方式的 GC 收集器：CMS（老年代唯一标记清理算法，会产生很多内存碎片） 选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。内存分配并发问题（补充内容，需要掌握）在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全： TLAB： 本地线程分配缓冲（Thread Local Allocation Buffer)，为每一个线程预先在 Eden 区分配一块儿内存。通过-XX:+&#x2F;-UseTLAB参数来设定虚拟机是否使用TLAB（JVM默认会开启-XX:+&#x2F;-UseTLAB），-XX:TLABSize指定TLAB大小。首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配 CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。 #Step3:初始化零值内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 #Step4:设置对象头初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 #Step5:执行 init 方法——构造方法在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始， 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 #对象的内存布局 信息 作用 哈希码 HashCode GC分代年龄 经历了多少次GC 锁状态标志 synchronized的标志 偏向线程ID 偏向锁偏向的线程ID 偏向时间戳 偏向的时间 数组大小 默认是4字节 类型指针 Klass Pointer 指向的类元数据的指针 【方法区】 指针压缩的作用点 在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：对象头、实例数据和对齐填充。Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 #对象的访问定位建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有：使用句柄、直接指针。 #句柄如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 #直接指针如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址。这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。 类加载器类加载过程 加载： 通过全类名获取获取二进制字节流； 将字节流转化为数据结构保存到方法区； 在Java堆中产生 java.lang.Class对象。Class对象是可以方法区的访问入口，用于Java反射机制，获取类的各种信息。 加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。 链接：验证：文件格式是否合法；准备：为类变量分配内存，并初始化为数据类型默认的零值（如 0、0L、null、false 等)解析：符号变量变为直接变量 初始化：**&lt;clinit&gt; ()方法**，在编译器收集静态变量说明： ()方法是编译之后自动生成的。对于 () 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。 #卸载卸载这部分内容来自 issue#662open in new window由 guang19open in new window 补充完善。卸载类即该类的 Class 对象被 GC。卸载类需要满足 3 个要求: 该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象。 该类没有在其他任何地方被引用 该类的类加载器的实例已被 GC 所以，在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。 类加载器详解JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader： BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由 C++实现，负责加载 %JAVA_HOME%&#x2F;lib目录下的 jar 包和类或者被 -Xbootclasspath参数指定的路径中的所有类。 ExtensionClassLoader(扩展类加载器) ：主要负责加载 %JRE_HOME%&#x2F;lib&#x2F;ext 目录下的 jar 包和类，或被 java.ext.dirs 系统变量所指定的路径下的 jar 包。 AppClassLoader(应用程序类加载器) ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。 双亲委派：系统中的 ClassLoader 在协同工作的时候会默认使用 双亲委派模型 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派给父类加载器的** loadClass() **处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。（非真正继承父类，只是指代优先级）AppClassLoader的父类加载器为ExtClassLoader， ExtClassLoader的父类加载器为 null，null 并不代表ExtClassLoader没有父类加载器，而是 BootstrapClassLoader双亲委派模型的好处优势： 优先级的等级制：避免类的重复加载 保护核心api不被修改 如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类 自定义类加载器除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义自己的类加载器，很明显需要继承 ClassLoader。 垃圾收集器大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为大于 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置默认值，这个值会在虚拟机运行过程中进行调整，可以通过-XX:+PrintTenuringDistribution来打印出当次 GC 后的 Threshold。Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的一半时，取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值”。经过这次 GC 后，Eden 区和”From”区已经被清空。这个时候，”From”和”To”会交换他们的角色。在这个过程中，有可能当次 Minor GC 后，Survivor 的”From”区域空间不够用，有一些还达不到进入老年代条件的实例放不下，则放不下的部分会提前进入老年代。针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：部分收集 (Partial GC)： 新生代收集（Minor GC &#x2F; Young GC）：只对新生代进行垃圾收集； 老年代收集（Major GC &#x2F; Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集； 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。 整堆收集 (Full GC)：收集整个 Java 堆和方法区。 #1.6 空间分配担保空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。《深入理解 Java 虚拟机》第三章对于空间分配担保的描述如下：JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 -XX:HandlePromotionFailure 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 -XX: HandlePromotionFailure 设置不允许冒险，那这时就要改为进行一次** Full GC。JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者之前young GC晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC.**Full GC条件：young GC平均晋升大小大于老年代的连续空间。young GC: eden区满了 2 对象已经死亡？堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。 #2.1 引用计数法给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。 2.2 可达性分析算法枚举一系列的对象称为 “GC Roots”哪些对象可以作为 GC Roots 呢？堆以外的，保存了堆上对象的引用，但是自己不在堆上。 虚拟机栈(栈帧中的本地变量表)中引用的对象 本地方法栈(Native 方法)中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 所有被同步锁持有的对象 对象可以被回收，就代表一定会被回收吗？即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。——直接回收被判定为需要执行finalize方法的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。Object 类中的 finalize 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 finalize 方法会被逐渐弃用移除。忘掉它的存在吧！ 2.5 如何判断一个常量是废弃常量？运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？ JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代 JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代 。 JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace) 假如在字符串常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。 #2.6 如何判断一个类是无用的类方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 “无用的类” ： 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。 垃圾收集器实现serial——serial old串行，简单高效，没有线程交互的开销 ParNew——CMS多个GC线程并行，serial的多线程版本 Parallel Scavenge——Parallel Old（JDK 1.8）多个GC线程并行，吞吐量优先 CMS (Concurrent mark sweep)并发运行，作用于老年代，响应速度优先，容易出现内存碎片三个标记过程：并发标记时间最长。stop the world: 初始标记、重新标记。 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ； 并发标记： 同时开启 GC 和用户线程，遍历对象图。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。 并发清理的时候：不能使用标记压缩，因为有用户线程在执行缺点：会产生内存碎片无法处理浮动垃圾：用户线程在并发标记过程中产生。并发标记过程虽然不会导致用户停顿，但是吞吐量降低。 G1(Garbage first)——（JDK 1.9）G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。 在region之间是，标记复制；整体上是标记整理。新生代并行（STW)，老年代并发。 优点：可预测的停顿 1.8 默认——parrallel Scavenge, parrallel old1.9默认——G1 异常OutOfMemoryError没有空闲内存，GC也无法提供内存 **java.lang.OutOfMemoryError: GC Overhead Limit Exceeded** ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。 **java.lang.OutOfMemoryError: Java heap space** :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过-Xmx参数配置，若没有特别配置，将会使用默认值，详见：Default Java 8 max heap sizeopen in new window) java.lang.OutOfMemoryError: Metaspace 原因：内存泄露可能导致内存溢出，gc频率变高；堆大小设置不够；创建了大量大对象。 内存泄漏对象不会再被用到，但是没有被GC回收。严格意义：忘记断开的引用。忘记关闭的数据库连接之类。 广义上内存泄漏：长周期的引用短周期 性能监控与调优 jps (JVM Process Status）: 类似 UNIX 的 ps 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息； jps -v：输出虚拟机进程启动时 JVM 参数。 jstat（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。 常见的 option 如下： jstat -class vmid ：显示 ClassLoader 的相关信息； jstat -compiler vmid ：显示 JIT 编译的相关信息； jstat -gc vmid ：显示与 GC 相关的堆信息； jstat -gccapacity vmid ：显示各个代的容量及使用情况； jstat -gcnew vmid ：显示新生代信息； jstat -gcnewcapcacity vmid ：显示新生代大小与使用情况； jstat -gcold vmid ：显示老年代和永久代的行为统计，从jdk1.8开始,该选项仅表示老年代，因为永久代被移除了； jstat -gcoldcapacity vmid ：显示老年代的大小； jstat -gcpermcapacity vmid ：显示永久代大小，从jdk1.8开始,该选项不存在了，因为永久代被移除了； jstat -gcutil vmid ：显示垃圾收集信息； jinfo (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息; 修改：进程结束后失效 jmap (Memory Map for Java) : 生成堆转储快照;j。 如果不使用 jmap 命令，要想获取 Java 堆转储，可以使用 “-XX:+HeapDumpOnOutOfMemoryError” 参数，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件，Linux 命令下可以通过 kill -3 发送进程退出信号也能拿到 dump 文件。 jhat (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP&#x2F;HTML 服务器，让用户可以在浏览器上查看分析结果; jstack (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。（当线程出现长时间停顿时使用）如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因 jcmd 除了jstat 来源： 尚硅谷：https://www.bilibili.com/video/BV1PJ411n7xZ?spm_id_from=333.337.search-card.all.click&amp;vd_source=31cbec680fd9e232150a7c8012c1968a Javaguide: https://javaguide.cn/","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"JVM阅读笔记，个人使用","slug":"JVM阅读笔记，个人使用","permalink":"http://example.com/tags/JVM%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%8C%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8/"}]},{"title":"MySQL总结","slug":"MySQL总结","date":"2022-07-05T14:36:26.142Z","updated":"2022-07-29T00:34:37.669Z","comments":true,"path":"2022/07/05/MySQL总结/","link":"","permalink":"http://example.com/2022/07/05/MySQL%E6%80%BB%E7%BB%93/","excerpt":"","text":"基本构架 innodb中存在Buffer Pool有了缓冲池后： 当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取,每次读取一整页。 当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。 innodb 为了防止预读失效，比方说在执行一个大的查询的时候，把所有的热点页都淘汰了。设置了old 区域 和 young 区域。innodb_old_blocks_pc 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。新的页放到冷数据区表头。如果两次访问时间超过1s, 则认定为（不是在全表扫描）热数据，移到热数据区。（全表扫描相邻的记录可能在同一页，所以两次访问时间要超过1s. 索引InnoDB索引模型叶子节点的内容，索引类型分为主键索引（聚簇索引（clustered index））和非主键索引（二级索引）。业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。（一般不用） 索引失效的原因对索引字段做操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。 日志Write-Ahead Logging(WAL)MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging（预写日志），它的关键点就是先写日志，再写磁盘。将随机的脏页写入变成顺序的日志刷盘。 redolog 何时刷盘innodb_flush_log_at_trx_commit 设置为[0，1，2](图中存在部分不准确）事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中，后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。（在这个过程中，会带走其他prepare阶段的日志）设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘（在这个过程中，会带走其他prepare阶段的日志)设置为 2 的时候，表示每次事务提交时都只是把** redo log 写到 page cache** 什么是 MySQL 的双1设置 ?**sync_binlog** 和 **innodb_flush_log_at_trx_commit** 都设置成 1一个事务完整提交前，需要等待两次刷盘：redo log（prepare 阶段）持久化到磁盘binlog 持久化到磁盘 Crash-Safe两阶段提交——保持主从数据库一致性redo log prepare———&gt;写binlog（用于更新从数据库）———–&gt;redo log commit 崩溃恢复 redolog 是否有commit，事务提交 redolog只有prepare, 拿XID 去 binlog 找对应的事务, 看是否有记录，有且完整，事务提交；无，事务回滚。 组提交介绍一下日志逻辑序列号 ?**log sequence number**，简称 LSNLSN 是单调递增的，对应每个 redo log 的写入点，值为上一个写入点 + 本次写入的 redo log 长度LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log如图三个并发事务：从图中可以看到，trx1 是第一个到达的，会被选为这组的 leader；等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160；trx1 去写盘的时候，带的就是 LSN&#x3D;160，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘；这时候 trx2 和 trx3 就可以直接返回了。所以，一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。MySQL 为了让组提交的效果更好，把 redo log 做 fsync 的时间拖到了步骤 1 之后。也就是说，上面的图变成了这样：不止redolog组提交；binlog也要组提交。在page cache中积累binlog，一起fsync. WAL 机制是减少磁盘写，但是每次提交事务都要写 redo log 和 binlog，这样读写次数不是很多吗 ?WAL 机制主要得益于两个方面： redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快 组提交机制，可以大幅度降低磁盘的 IOPS (io per second)消耗 如果你的 MySQL 现在出现了性能瓶颈，而且瓶颈在 IO 上，可以通过哪些方法来提升性能呢 ?将** binlog 的提交延迟设置大一点，增加组提交的组员，减少写盘次数不用双一：都修改为大于1的值将 sync_binlog 设置为大于1的值，但这可能导致出现数据丢失的风险（主机宕机时）**将 innodb_flush_log_at_trx_commit 设置为2，但这可能导致出现数据丢失的风险（主机宕机时） 事务ACID：原子性、一致性、隔离性、持久性 并发事务问题脏读：一个事务读到另一个事务还未提交的数据修改丢失：两个事务同时修改，其中一个事务修改丢失不可重复读：同一个事务前后，读取同一条记录不一致幻读：查询时没有对应行，插入时确已经存在。 事务的隔离性 可重复读的实现事务数组，未提交的事务。当前活跃的事务tx_id基于数据行的 trx_id和这个一致性视图的对比结果得到的。 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的； 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的； a. 若 trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；b. 若 trx_id不在数组中，表示这个版本是已经提交了的事务生成的（虽然可能生成的晚，但是已经提交），可见。 快照读（一致性读）和当前读 快照读： 读取的是记录数据的可见版本(MVCC)（有旧的版本）。不加锁,普通的select语句都是快照读,如：select * from user where id &#x3D; 1;当前读：读取的是记录数据的最新版本，显式加锁的都是当前读, 与MVCC、事务无关select * from user where id &#x3D; 1 for update;select * from user where id &#x3D; 1 lock in share mode;update, insert，delete语句 ， 例如，假设要update一条记录，但是另一个事务已经delete这条数据并且commit了，如果不加锁就会产生冲突。所以update的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。 MVCC能否解决了幻读问题呢？有关这个问题查了很多资料,有的说能解决，有的说不能解决，也有人说能解决部分幻读场景。这里部分解决指的是能解决~~~~快照读~~~~的幻读问题，不能解决~~~~当前读~~~~的幻读问题。具体可以看下面这篇文章面试题之：MVCC能否解决幻读？https://blog.csdn.net/qq_35590091&#x2F;article&#x2F;details&#x2F;107734005先说我的结论:MVCC能解决不可重复读问题,但是不能解决幻读问题，不论是快照读和当前读都不能解决。RR级别解决幻读靠的是锁机制,而不是MVCC机制。既然网上那么多人说，MVCC解决能解决快照读下的幻读问题， 那这里通过举示例来说明,MVCC解决不了快照读的幻读问题。假设有张用户表,这张表的 id 是主键。表中一开始有4条数据。 这里是在RR级别下研究(可重复读)。 1、事务A,查询是否存在 id&#x3D;5 的记录，没有则插入，这是我们期望的正常业务逻辑。2、这个时候 事务B 新增的一条 id&#x3D;5 的记录，并提交事务。3、事务A,再去查询 id&#x3D;5 的时候,发现还是没有记录。上面的文章是这样来举例说明,事务A第一次和第二次读到的是一样的，所以认为解决了幻读。我不认为这个是解决了幻读，而是解决了不可能重复读。它保证了第一次和第二次所读到的结果是一样的。解决幻读了吗？显然没有，因为这个时候如果事务A执行一条插入操作INSERT INTO user (id, name, pwd) VALUES (5, ‘田七’, ‘fff’); 最终 事务A 提交事务，发现报错了。这就很奇怪，查的时候明明没有这条记录，但插入的时候 却告诉我 主键冲突，这就好像幻觉一样。这才是幻读问题。所以说MVCC是不能解决的，要想解决还是需要锁。这里事务A能正常的插入的前提就是其它事务不能插入id&#x3D;5并提交成功。要解决这个问题也很简单，就是事务A先获得id&#x3D;5这个排它锁。我们可以在事务A第一次查询的时候加一个排他锁select * from user where id = 5 for update那么事务B的插入动作永远属于堵塞状态，直到事务A插入成功，并提交。那么最终是事务B报主键冲突而回滚。但事务A不会因为查询的时候没有这条记录，插入失败。也就解决了幻读问题。所以说 RR级别下解决幻读问题靠的是锁机制，而不是MVCC机制。 锁 主从复制备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接。一个事务日志同步的完整过程是这样的： 在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。 在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。 主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。 备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。 sql_thread读取中转日志，解析出日志里的命令，并执行。 减少主备延迟coordinator就是原来的sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了worker线程。而work线程的个数，就是由参数**slave_parallel_workers**决定的。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"第80场双周赛 TP-Link","slug":"第80场 双周赛TP-Link","date":"2022-06-25T01:02:22.398Z","updated":"2022-07-30T06:57:18.630Z","comments":true,"path":"2022/06/25/第80场 双周赛TP-Link/","link":"","permalink":"http://example.com/2022/06/25/%E7%AC%AC80%E5%9C%BA%20%E5%8F%8C%E5%91%A8%E8%B5%9BTP-Link/","excerpt":"","text":"前两题略 2301. 替换字符后匹配难度困难10收藏分享切换为英文接收动态反馈给你两个字符串 s 和 sub 。同时给你一个二维字符数组 mappings ，其中 mappings[i] &#x3D; [oldi, newi] 表示你可以将 sub 中任意数目的 oldi 字符替换为 newi 。sub 中每个字符 不能 被替换超过一次。如果使用 mappings 替换 0 个或者若干个字符，可以将 sub 变成 s 的一个子字符串，请你返回 true，否则返回 false 。一个 子字符串 是字符串中连续非空的字符序列。 示例 1：输入：s &#x3D; “fool3e7bar”, sub &#x3D; “leet”, mappings &#x3D; [[“e”,”3”],[“t”,”7”],[“t”,”8”]] 输出：true 解释：将 sub 中第一个 ‘e’ 用 ‘3’ 替换，将 ‘t’ 用 ‘7’ 替换。 现在 sub &#x3D; “l3e7” ，它是 s 的子字符串，所以我们返回 true 。 思路：使用一个boolean[][] vis 数组，记录mapppings映射关系。（或者使用HashMap&lt;Character, set&gt;); 时间复杂度：O（mn), 先找到s 字符串中的起始点，再开始遍历字符串sub. 12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean matchReplacement(String s, String sub, char[][] mappings) &#123; boolean[][] vis=new boolean[128][128]; for (int i = 0; i &lt; mappings.length; i++) &#123; vis[mappings[i][0]-&#x27;0&#x27;][mappings[i][1]-&#x27;0&#x27;]=true; &#125; // char start=sub.charAt(0); for (int i = 0; i &lt; s.length() &amp;&amp; i+sub.length()-1&lt;s.length(); i++) &#123; char c=s.charAt(i); if(c==start || vis[start-&#x27;0&#x27;][c-&#x27;0&#x27;])&#123; if(match(s.substring(i+1),sub.substring(1),vis))&#123; return true; &#125; &#125; &#125; return false; &#125; private boolean match(String s, String sub, boolean[][] vis)&#123; for (int i = 0; i &lt; sub.length(); i++) &#123; if(s.charAt(i)!=sub.charAt(i) &amp;&amp; !vis[sub.charAt(i)-&#x27;0&#x27;][s.charAt(i)-&#x27;0&#x27;])&#123; return false; &#125; &#125; return true; &#125; &#125; 2302. 统计得分小于 K 的子数组数目难度困难9收藏分享切换为英文接收动态反馈一个数字的 分数 定义为数组之和 乘以 数组的长度。 比方说，[1, 2, 3, 4, 5] 的分数为 (1 + 2 + 3 + 4 + 5) * 5 &#x3D; 75 。 给你一个正整数数组 nums 和一个整数 k ，请你返回 nums 中分数 **严格小于 **k 的 非空整数子数组数目。子数组 是数组中的一个连续元素序列。————&gt;滑动窗口 示例 1：输入：nums &#x3D; [2,1,4,3,5], k &#x3D; 10 输出：6 解释： 有 6 个子数组的分数小于 10 ： - [2] 分数为 2 * 1 &#x3D; 2 。 - [1] 分数为 1 * 1 &#x3D; 1 。 - [4] 分数为 4 * 1 &#x3D; 4 。 - [3] 分数为 3 * 1 &#x3D; 3 。 - [5] 分数为 5 * 1 &#x3D; 5 。 - [2,1] 分数为 (2 + 1) * 2 &#x3D; 6 。 注意，子数组 [1,4] 和 [4,3,5] 不符合要求，因为它们的分数分别为 10 和 36，但我们要求子数组的分数严格小于 10 。 思路：滑动窗口，右拉左。时间复杂度：O（n) 1234567891011121314151617181920212223class Solution &#123; public long countSubarrays(int[] nums, long k) &#123; long ans=0; long sum=0; //left和right组成的滑动窗口 for(int left=0, right=0;right&lt;nums.length;right++)&#123; sum+=nums[right]; //左边界右移 while(sum*(right-left+1)&gt;=k)&#123; sum-=nums[left]; left++; &#125; //计算当前左，右边界，满足条件的所有子数组 ans+=right-left+1; &#125; return ans; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"周赛","slug":"周赛","permalink":"http://example.com/tags/%E5%91%A8%E8%B5%9B/"}]},{"title":"单例模式","slug":"单例模式","date":"2022-06-23T13:25:44.106Z","updated":"2022-07-29T00:35:57.092Z","comments":true,"path":"2022/06/23/单例模式/","link":"","permalink":"http://example.com/2022/06/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"懒汉式——线程不安全、线程安全、DCL（锁的优化）饿汉式静态内部类枚举 应用场景：JDK中runtime类，spring里bean默认单例 1、懒汉式，线程不安全是否 Lazy 初始化：是是否多线程安全：否实现难度：易描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 实例123456789101112public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; //public接口返回实例 public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。 2、懒汉式，线程安全是否 Lazy 初始化：是是否多线程安全：是实现难度：易描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 实例12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 3、饿汉式是否 Lazy 初始化：否是否多线程安全：是，由JVM类加载机制保证。实现难度：易描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 类的加载过程：1.加载2.链接：a. 验证 b.准备（给类的静态成员变量赋默认值） c.解析3.初始化：类静态成员变量初始化 实例1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 4、双检锁&#x2F;双重校验锁（DCL，即 double-checked locking）JDK 版本：JDK1.5 起是否 Lazy 初始化：是是否多线程安全：是实现难度：较复杂，同步代码块描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。 1234567891011121314151617181920212223/** * double checked lock 懒汉式 */public class SingletonDemo &#123; //volatile禁止指令重排 private static volatile SingletonDemo instance=null; private SingletonDemo() &#123; &#125; public static SingletonDemo getInstance()&#123; //减小锁的粒度 if(instance==null)&#123; synchronized (SingletonDemo.class)&#123; //保证同步 if(instance==null)&#123; instance=new SingletonDemo(); &#125; &#125; &#125; //另外一个线程会拿到未初始化的实例 return instance; &#125;&#125; 为什么DCL要使用volatileDCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入volatile可以禁止指令重排原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象可能没有完成实例化。因为instance &#x3D; new SingletonDemo()；可以分为以下三步进行完成： memory &#x3D; allocate(); &#x2F;&#x2F; 1、分配对象内存空间 instance(memory); &#x2F;&#x2F; 2、初始化对象 instance &#x3D; memory; &#x2F;&#x2F; 3、设置instance指向刚刚分配的内存地址，此时instance !&#x3D; null 但是我们通过上面的三个步骤，能够发现，步骤2 和 步骤3之间不存在 数据依赖关系，而且无论重排前 还是重排后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。顺序的情况下，new指令申请了一块内存空间，invokespecial调用构造方法为对象进行初始化，astore_1将变量和新创建的对象关联起来。但是invokespecial和astore_1这两条指令没有关联性，所以astore_1有可能会跑到invokespecial前面执行。如图，假设两个线程，线程1执行完astore_1时(此时instance已经指向一块内存地址，不为null，但是对象还未完成初始化)，CPU切换到线程2执行if(instance&#x3D;&#x3D;null)，结果为false，于是返回了一个不完整的对象。使用volatile禁止指令重排就可以避免这种情况发生。 5、登记式&#x2F;静态内部类是否 Lazy 初始化：是是否多线程安全：是实现难度：一般描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 123456789101112131415public class SingleTon &#123; //创建私有的构造方法 private SingleTon()&#123; &#125; //2.在类内部创建一个对象，不使用静态内部类的成员不会加载 private static class Holder&#123; private static final SingleTon instance = new SingleTon(); &#125; //3.定义一个公开的方法来获得单例对象 public static SingleTon getInstance()&#123; //静态类直接通过类调用 return Holder.instance; &#125;&#125; 6. 枚举1234567891011121314151617public enum Singleton &#123; INSTANCE; public void businessMethod() &#123; System.out.println(&quot;我是一个单例！&quot;); &#125;&#125;public class MainClass &#123; public static void main(String[] args) &#123; //调用枚举类对象 Singleton s1 = Singleton.INSTANCE; Singleton s2 = Singleton.INSTANCE; System.out.println(s1==s2); &#125;&#125; 反射机制破解单例模式（枚举除外）：通过反射拿到私有的构造器 123456789101112131415public class BreakSingleton&#123; public static void main(String[] args) throw Exception&#123; Class clazz = Class.forName(&quot;Singleton&quot;); Constructor c = clazz.getDeclaredConstructor(null); c.setAccessible(true); //构造器c.newInstance() Singleton s1 = c.newInstance(); Singleton s2 = c.newInstance(); //通过反射，得到的两个不同对象 System.out.println(s1); System.out.println(s2); &#125;&#125; 如何避免以上的漏洞： 123456789101112class Singleton&#123; private static final Singleton singleton = new Singleton(); private Singleton() &#123; //在构造器中加个逻辑判断,多次调用,抛出异常 if(instance!= null)&#123; throw new RuntimeException() &#125; &#125; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 序列化，反序列化破坏序列化会通过反射调用无参数的构造方法创建一个新的对象。 1234567891011121314151617181920package com.hollis;import java.io.*;/** * Created by hollis on 16/2/5. */public class SerializableDemo1 &#123; //为了便于理解，忽略关闭流操作及删除文件操作。真正编码时千万不要忘记 //Exception直接抛出 public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //Write Obj to file ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;tempFile&quot;)); oos.writeObject(Singleton.getSingleton()); //Read Obj from file File file = new File(&quot;tempFile&quot;); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); Singleton newInstance = (Singleton) ois.readObject(); //判断是否是同一个对象 System.out.println(newInstance == Singleton.getSingleton()); &#125;&#125; isInstantiable：如果一个serializable&#x2F;externalizable的类可以在运行时被实例化，那么该方法就返回true。desc.newInstance：该方法通过反射的方式调用无参构造方法新建一个对象。 123456Object obj;try &#123; obj = desc.isInstantiable() ? desc.newInstance() : null;&#125; catch (Exception ex) &#123; throw (IOException) new InvalidClassException(desc.forClass().getName(),&quot;unable to create instance&quot;).initCause(ex);&#125; 如何避免实现序列化单例模式的漏洞：先给出解决方案，然后再具体分析原理：只要在Singleton类中定义readResolve就可以解决该问题：应用：currency类 12345678910111213141516171819202122232425package com.hollis;import java.io.Serializable;/** * Created by hollis on 16/2/5. * 使用双重校验锁方式实现单例 */public class Singleton implements Serializable&#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; //返回单例 private Object readResolve() &#123; return singleton; &#125;&#125; 123456789101112if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123; Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) &#123; rep = cloneArray(rep); &#125; if (rep != obj) &#123; handles.setObject(passHandle, obj = rep); &#125; &#125; hasReadResolveMethod:如果实现了serializable 或者 externalizable接口的类中包含readResolve则返回trueinvokeReadResolve:通过反射的方式调用要被反序列化的类的readResolve方法。所以，原理也就清楚了，主要在Singleton中定义readResolve方法，并在该方法中指定要返回的对象的生成策略，就可以防止单例被破坏。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"并查集与拓扑排序","slug":"并查集和拓扑排序","date":"2022-06-22T07:26:15.151Z","updated":"2022-07-05T17:12:33.721Z","comments":true,"path":"2022/06/22/并查集和拓扑排序/","link":"","permalink":"http://example.com/2022/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%92%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","excerpt":"","text":"并查集：无向图，只有边的概念。UnionFind:拓扑排序：有向图，点有入度和出度。从入度为0的点开始排序（没有前置条件） 是否有环无向图：并查集，要加入的边，两边的点已经在同一集合了。有向图：拓扑排序，看是否所有的点的入度都可以消除为0。使用一个栈，保存所有入度&#x3D;0的点，可以加入结果集，并且用set&#x2F;list保存了当前点的下一个点，由此删除下一个点的入度。如图所示有向图，无环，可以生成一个拓扑排序示例 1：输入：“1-&gt;2,2-&gt;3,3-&gt;1”输出：true示例 2：输入：“1-&gt;4,2-&gt;5,3-&gt;6,3-&gt;7,4-&gt;8,5-&gt;8,5-&gt;9,6-&gt;9,6-&gt;11,7-&gt;11,8-&gt;12,9-&gt;12,9-&gt;13,10-&gt;13,10-&gt;14,11-&gt;10,11-&gt;14”输出：false示例 3：输入：“1-&gt;4,2-&gt;5,3-&gt;6,3-&gt;7,4-&gt;8,5-&gt;8,5-&gt;9,6-&gt;9,6-&gt;11,7-&gt;11,8-&gt;12,9-&gt;12,9-&gt;13,10-&gt;6,10-&gt;13,10-&gt;14,11-&gt;10,11-&gt;14”输出：true解释:存在环线:6-&gt;11,11-&gt;10,10-&gt;6提示: 0 &lt; 节点数 &lt; 100123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import org.junit.Test;import java.util.ArrayDeque;import java.util.ArrayList;import java.util.HashSet;public class LeetCode &#123; @Test public void test() &#123; Solution so = new Solution(); System.out.println(so.hasCycle(&quot;1-&gt;4,2-&gt;5,3-&gt;6,3-&gt;7,4-&gt;8,5-&gt;8,5-&gt;9,6-&gt;9,6-&gt;11,7-&gt;11,8-&gt;12,9-&gt;12,9-&gt;13,10-&gt;6,10-&gt;13,10-&gt;14,11-&gt;10,11-&gt;14&quot;)); &#125; class Solution &#123; public boolean hasCycle(String graph) &#123; String[] split = graph.split(&quot;,&quot;); int n = split.length; //存所有节点 HashSet&lt;Integer&gt; node = new HashSet&lt;&gt;(); //入度 int[] inpoint = new int[2 * n + 1]; boolean[] visited = new boolean[2 * n + 1]; //next step,数组 HashSet&lt;Integer&gt;[] list = new HashSet[2 * n + 1]; for (int i = 0; i &lt; n; i++) &#123; String[] strings = new String[2]; strings = split[i].split(&quot;-&gt;&quot;); int u = Integer.parseInt(strings[0]); int v = Integer.parseInt(strings[1]); node.add(u); node.add(v); visited[v] = true; visited[u] = true; //入度 inpoint[v]++; if (list[u] == null) &#123; list[u] = new HashSet&lt;&gt;(); &#125; //邻接表 list[u].add(v); &#125; ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(2 * n + 1); for (int i = 0; i &lt; 2 * n + 1; i++) &#123; if (visited[i] &amp;&amp; inpoint[i] == 0) &#123; stack.add(i); &#125; &#125; //所有入度可减小为0的点，可排序的点 ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); while (!stack.isEmpty()) &#123; int cur = stack.poll(); integers.add(cur); if (list[cur] != null) &#123; for (Integer i : list[cur]) &#123; inpoint[i]--; if (inpoint[i] == 0) &#123; stack.push(i); &#125; &#125; &#125; &#125; return integers.size() &lt; node.size(); &#125; &#125;&#125; 无向图是否存在环join的时候，利用find进行路径压缩 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; /** 并查集（union-find, 或disjoint set）可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。 初始化：所有点的母节点为自己 每次要连接节点i 和j 时，我们可以将i 的父亲标为j； 每次要查询两个节点是否相连时，我们可以查找i 和j 的祖先是否最终为同一个人。 1.find：找到祖先 2.same:是否在同一个集合，同一根节点 3.join,将两个节点连在同一节点 */ private int n; private int[] father; public Solution()&#123; n=1005; father=new int[n]; for(int i=0;i&lt;n;i++)&#123; father[i]=i;//父节点 &#125; &#125; //找到祖先 public int find(int u)&#123; if(u==father[u]) return u;//base case:是根 father[u]=find(father[u]);//迭代找到祖先 return father[u]; &#125; //是否在同一集合，同一个根节点，就在同一集合 public boolean same(int u,int v)&#123; u=find(u); v=find(v); return u==v; &#125; //v-&gt;u 这条边加入并查集，调用find,进行路径压缩，直接与连在根节点上 public void join(int u,int v)&#123; u=find(u); v=find(v); if(u==v) return;//已经存在 father[v]=u; &#125; //遍历边，如果已经在同一集合，结果又有新边，返回这条新边 //在并查集加入新边 //solution不用自己new public int[] findRedundantConnection(int[][] edges) &#123; for(int[] line:edges)&#123; if(same(line[0],line[1])) return line; else join(line[0],line[1]); &#125; return new int[]&#123;&#125;; &#125;&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"494.目标和","slug":"494 目标和","date":"2022-06-20T10:20:21.777Z","updated":"2022-06-20T11:37:15.088Z","comments":true,"path":"2022/06/20/494 目标和/","link":"","permalink":"http://example.com/2022/06/20/494%20%E7%9B%AE%E6%A0%87%E5%92%8C/","excerpt":"","text":"494. 目标和难度中等1166 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &quot;+2-1&quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 12345678输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3 123456789101112131415161718192021222324252627class Solution &#123; //0,1背包问题 //找到子集为4的集合 public int findTargetSumWays(int[] nums, int target) &#123; int n=nums.length; int sum=0; for(int num:nums)&#123; sum+=num; &#125; int weight= (sum+target)&gt;&gt;1; if((sum+target)%2==1 || weight&lt;0)&#123; return 0; &#125; int[] dp=new int[weight+1]; dp[0]=1;//初始化 for(int num:nums)&#123;//枚举i的质量 for(int j=weight;j&gt;=num;j--)&#123;//循环背包，-- dp[j]+=dp[j-num]; &#125; &#125; return dp[weight]; &#125;&#125;","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"494.目标和","slug":"416 背包问题","date":"2022-06-20T10:20:21.775Z","updated":"2022-06-20T11:37:39.775Z","comments":true,"path":"2022/06/20/416 背包问题/","link":"","permalink":"http://example.com/2022/06/20/416%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"416. 分割等和子集难度中等1213 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 123输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。 dp[ i] [j ]:长度为i的数组，可选可不选（0，1），他们的和能组成j,是true还是false 边界条件：dp [] [0]&#x3D;true,这样状态转移方程中dp[i-1] [j-nums[i]]能等于true. 也可使用记忆化深度优先搜索。 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum=0; for(int element:nums) &#123; sum+=element; &#125; if(sum%2==1) &#123; return false; &#125; return dfs(nums,0,0,sum,new HashMap&lt;String,Boolean&gt;()); &#125; public boolean dfs(int[]nums,int index,int sum,int target, HashMap&lt;String,Boolean&gt; map) &#123; //map.put(index+&quot;&quot;+sum,); if(map.containsKey(index+&quot;&quot;+sum)) &#123; return map.get(index+&quot;&quot;+sum);//在其他分支中已经算过的，相同的层次，相同的sum &#125; if(sum*2==target) &#123; return true; &#125; if(sum&gt;target/2 || index&gt;=nums.length) &#123; return false; &#125; boolean partition= dfs(nums,index+1,sum+nums[index],target,map)||dfs(nums,index+1,sum,target,map); map.put(index+&quot;&quot;+sum, partition); return partition; &#125;&#125; dp:空间压缩 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum=0; for(int element:nums) &#123; sum+=element; &#125; if(sum%2==1) &#123; return false; &#125; int target=sum/2; int n=nums.length; boolean[]dp=new boolean[target+1]; dp[0]=true; for(int i=1;i&lt;n+1;i++)&#123;//每一个i循环填充一个dp数组 for(int j=target;j&gt;0;j--) &#123;//倒序遍历，取得上一行（i-1)数值 if(j&gt;=nums[i-1]) dp[j]=dp[j]||dp[j-nums[i-1]]; else &#123; dp[j]=dp[j]; &#125; &#125; &#125; return dp[target]; &#125; &#125; 因为j-nums[i]&lt;j, 所以倒序。若按照从左往右的顺序进行正向遍历，则dp[j-w] 的值在遍历到j 之前就已经被更新成物品i 的值了。","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"312. 戳气球","slug":"312 戳气球","date":"2022-06-20T10:20:21.774Z","updated":"2022-06-20T11:37:58.409Z","comments":true,"path":"2022/06/20/312 戳气球/","link":"","permalink":"http://example.com/2022/06/20/312%20%E6%88%B3%E6%B0%94%E7%90%83/","excerpt":"","text":"312. 戳气球难度困难972 有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。 求所能获得硬币的最大数量。 示例 1： 12345输入：nums = [3,1,5,8]输出：167解释：nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 思路：如何找子问题（备忘录）存起来 123456789101112131415161718192021222324252627282930313233343536/** *动态规划自底向上 * * 最后一个爆破的气球可以把左右区间区分开，他们之间没有关联（不会相乘），由此将这个问题分为两个子问题 * dp[i][j]:在i到j之间能得到的最大值，不包括i,j * 逆向思考：k是最后一个爆破的气球，在(i,j)之间遍历k,取最大值 * */class Solution &#123; public int maxCoins(int[] nums) &#123; int n=nums.length; int[] tmp=new int[n+2]; int[][] dp=new int[n+2][n+2]; System.arraycopy(nums,0,tmp,1,n); tmp[0]=1; tmp[n+1]=1; for (int i =n-1; i &gt;=0; i--) &#123;//开区间(i,j) for (int j = i+2; j &lt;=n+1 ; j++) &#123; for (int k = i+1; k &lt;j; k++) &#123; dp[i][j]=Math.max(dp[i][j],dp[i][k]+dp[k][j]+tmp[k]*tmp[i]*tmp[j]); //dp[i][k]和dp[k][j]中j&gt;i+1, // 同时因为k&gt;i,所以i要从大到小遍历 &#125; &#125; &#125; return dp[0][n+1]; &#125;&#125;","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"279.完全平方数","slug":"279 分割类问题","date":"2022-06-20T10:20:21.772Z","updated":"2022-06-20T11:38:39.996Z","comments":true,"path":"2022/06/20/279 分割类问题/","link":"","permalink":"http://example.com/2022/06/20/279%20%E5%88%86%E5%89%B2%E7%B1%BB%E9%97%AE%E9%A2%98/","excerpt":"","text":"279. 完全平方数难度中等1288 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 123输入：n = 12输出：3 解释：12 = 4 + 4 + 4 示例 2： 123输入：n = 13输出：2解释：13 = 4 + 9 提示： 1 &lt;= n &lt;= 104 题解：","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"213. 打家劫舍 II","slug":"213 打家劫舍II","date":"2022-06-20T10:20:21.769Z","updated":"2022-06-20T11:39:30.274Z","comments":true,"path":"2022/06/20/213 打家劫舍II/","link":"","permalink":"http://example.com/2022/06/20/213%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/","excerpt":"","text":"213. 打家劫舍 II难度中等1025 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 123输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 12345678910111213141516171819202122232425262728293031class Solution &#123; /** 环形导致的bug点在于，可能导致第一家和最后一家都偷了。 所以考虑不偷第一家，和不偷最后一家。 不偷，即初始化为0。 这两种情况中肯定有一种是最优解。找到其最大值，就是最优解。 */ public int rob(int[] nums) &#123; int n=nums.length; int[] dp=new int[n]; if(n==1) return nums[0]; if(n==2) return Math.max(nums[0],nums[1]); dp[0]=0;//不偷0 dp[1]=nums[1]; for(int i=2;i&lt;=n-1;i++)&#123;//不偷第一家[1,n-1] dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);//不偷，偷 &#125; int[] dp2=new int[n]; dp2[n-1]=0;//不偷n-1 dp2[n-2]=nums[n-2]; for(int i=n-3;i&gt;=0;i--)&#123;//不偷最后一家[0,n-2] dp2[i]=Math.max(dp2[i+1],dp2[i+2]+nums[i]); &#125; return Math.max(dp[n-1],dp2[0]); &#125; &#125;","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"198.打家劫舍","slug":"198 打家劫舍I","date":"2022-06-20T10:20:21.768Z","updated":"2022-07-30T06:57:04.320Z","comments":true,"path":"2022/06/20/198 打家劫舍I/","link":"","permalink":"http://example.com/2022/06/20/198%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DI/","excerpt":"","text":"定义子问题 写出子问题的递推关系 画图：子结构 思路：动态规划。 定义子问题——偷K间房屋能偷到的最大金额: f(K) 状态转移方程——第K间房屋只有两种选择，偷或者不偷。f(K)&#x3D;max{nums[K-1]+f(K-2),f(K-1)} 边界条件：没有房屋&amp;只有一间房屋 TC:O(N) SC:O(N) 123456789101112131415class Solution &#123; public int rob(int[] nums) &#123; if(nums==null||nums.length==0)&#123; return -1; &#125; int N=nums.length; int[] dp= new int[N+1]; dp[0]=0; dp[1]=nums[0]; for(int i=2;i&lt;=N;i++)&#123; dp[i]=Math.max(dp[i-1],nums[i-1]+dp[i-2]);//自底向上，dp[i]：偷前i间最大金额 &#125; return dp[N]; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"2226.每个小孩最多能分多少糖果","slug":"2226 分糖果","date":"2022-06-20T10:13:13.789Z","updated":"2022-06-20T11:31:52.346Z","comments":true,"path":"2022/06/20/2226 分糖果/","link":"","permalink":"http://example.com/2022/06/20/2226%20%E5%88%86%E7%B3%96%E6%9E%9C/","excerpt":"","text":"2226. 每个小孩最多能分到多少糖果难度中等18 给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。 另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。 返回每个小孩可以拿走的 最大糖果数目 。 1234567891011121314151617181920class Solution &#123; public int maximumCandies(int[] candies, long k) &#123; long max=(long)1e7; // int min=candies[0]; long left=-1; long right=max+1; while(left+1!=right)&#123;// long mid=left+(right-left)/2; long count=0; if(mid==0) return 0; for(int num:candies)&#123; count+=num/mid; &#125; if(count&lt;k) right=mid; else left=mid;足条件的最大值 &#125; return (int)left;//返回Left &#125;&#125;","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]}],"categories":[{"name":"开源项目","slug":"开源项目","permalink":"http://example.com/categories/%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"题解","slug":"题解","permalink":"http://example.com/categories/%E9%A2%98%E8%A7%A3/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"项目","slug":"项目","permalink":"http://example.com/tags/%E9%A1%B9%E7%9B%AE/"},{"name":"Java基础笔记","slug":"Java基础笔记","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0/"},{"name":"剑指 Offer","slug":"剑指-Offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87-Offer/"},{"name":"JVM阅读笔记，个人使用","slug":"JVM阅读笔记，个人使用","permalink":"http://example.com/tags/JVM%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%EF%BC%8C%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"周赛","slug":"周赛","permalink":"http://example.com/tags/%E5%91%A8%E8%B5%9B/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]}
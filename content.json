{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"标题","date":"2022-06-20T11:30:37.378Z","updated":"2022-06-20T11:30:37.378Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"学生"}],"posts":[{"title":"MySQL总结","slug":"MySQL总结","date":"2022-07-05T14:36:26.142Z","updated":"2022-07-05T17:15:20.827Z","comments":true,"path":"2022/07/05/MySQL总结/","link":"","permalink":"http://example.com/2022/07/05/MySQL%E6%80%BB%E7%BB%93/","excerpt":"","text":"基本构架 innodb中存在Buffer Pool有了缓冲池后： 当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取,每次读取一整页。 当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。 innodb 为了防止预读失效，比方说在执行一个大的查询的时候，把所有的热点页都淘汰了。设置了old 区域 和 young 区域。innodb_old_blocks_pc 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。新的页放到冷数据区表头。如果两次访问时间超过1s, 则认定为（不是在全表扫描）热数据，移到热数据区。（全表扫描相邻的记录可能在同一页，所以两次访问时间要超过1s. 索引InnoDB索引模型叶子节点的内容，索引类型分为主键索引（聚簇索引（clustered index））和非主键索引（二级索引）。业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。（一般不用） 索引失效的原因对索引字段做操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。 日志Write-Ahead Logging(WAL)MySQL里经常说到的WAL技术，WAL的全称是Write-Ahead Logging（预写日志），它的关键点就是先写日志，再写磁盘。将随机的脏页写入变成顺序的日志刷盘。 redolog 何时刷盘innodb_flush_log_at_trx_commit 设置为[0，1，2](图中存在部分不准确）事务执行中间过程的 redo log 也是直接写在 redo log buffer 中的，这些 redo log 也会被后台线程一起持久化到磁盘。设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中，后台线程，每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。（在这个过程中，会带走其他prepare阶段的日志）设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘（在这个过程中，会带走其他prepare阶段的日志)设置为 2 的时候，表示每次事务提交时都只是把** redo log 写到 page cache** 什么是 MySQL 的双1设置 ?**sync_binlog** 和 **innodb_flush_log_at_trx_commit** 都设置成 1一个事务完整提交前，需要等待两次刷盘：redo log（prepare 阶段）持久化到磁盘binlog 持久化到磁盘 Crash-Safe两阶段提交——保持主从数据库一致性redo log prepare———&gt;写binlog（用于更新从数据库）———–&gt;redo log commit 崩溃恢复 redolog 是否有commit，事务提交 redolog只有prepare, 拿XID 去 binlog 找对应的事务, 看是否有记录，有且完整，事务提交；无，事务回滚。 组提交介绍一下日志逻辑序列号 ?**log sequence number**，简称 LSNLSN 是单调递增的，对应每个 redo log 的写入点，值为上一个写入点 + 本次写入的 redo log 长度LSN 也会写到 InnoDB 的数据页中，来确保数据页不会被多次执行重复的 redo log如图三个并发事务：从图中可以看到，trx1 是第一个到达的，会被选为这组的 leader；等 trx1 要开始写盘的时候，这个组里面已经有了三个事务，这时候 LSN 也变成了 160；trx1 去写盘的时候，带的就是 LSN&#x3D;160，因此等 trx1 返回时，所有 LSN 小于等于 160 的 redo log，都已经被持久化到磁盘；这时候 trx2 和 trx3 就可以直接返回了。所以，一次组提交里面，组员越多，节约磁盘 IOPS 的效果越好。但如果只有单线程压测，那就只能老老实实地一个事务对应一次持久化操作了。MySQL 为了让组提交的效果更好，把 redo log 做 fsync 的时间拖到了步骤 1 之后。也就是说，上面的图变成了这样：不止redolog组提交；binlog也要组提交。在page cache中积累binlog，一起fsync. WAL 机制是减少磁盘写，但是每次提交事务都要写 redo log 和 binlog，这样读写次数不是很多吗 ?WAL 机制主要得益于两个方面： redo log 和 binlog 都是顺序写，磁盘的顺序写比随机写速度要快 组提交机制，可以大幅度降低磁盘的 IOPS (io per second)消耗 如果你的 MySQL 现在出现了性能瓶颈，而且瓶颈在 IO 上，可以通过哪些方法来提升性能呢 ?将** binlog 的提交延迟设置大一点，增加组提交的组员，减少写盘次数不用双一：都修改为大于1的值将 sync_binlog 设置为大于1的值，但这可能导致出现数据丢失的风险（主机宕机时）**将 innodb_flush_log_at_trx_commit 设置为2，但这可能导致出现数据丢失的风险（主机宕机时） 事务ACID：原子性、一致性、隔离性、持久性 并发事务问题脏读：一个事务读到另一个事务还未提交的数据修改丢失：两个事务同时修改，其中一个事务修改丢失不可重复读：同一个事务前后，读取同一条记录不一致幻读：查询时没有对应行，插入时确已经存在。 事务的隔离性 可重复读的实现事务数组，未提交的事务。当前活跃的事务tx_id基于数据行的 trx_id和这个一致性视图的对比结果得到的。 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的； 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的； a. 若 trx_id在数组中，表示这个版本是由还没提交的事务生成的，不可见；b. 若 trx_id不在数组中，表示这个版本是已经提交了的事务生成的（虽然可能生成的晚，但是已经提交），可见。 快照读（一致性读）和当前读 快照读： 读取的是记录数据的可见版本(MVCC)（有旧的版本）。不加锁,普通的select语句都是快照读,如：select * from user where id &#x3D; 1;当前读：读取的是记录数据的最新版本，显式加锁的都是当前读, 与MVCC、事务无关select * from user where id &#x3D; 1 for update;select * from user where id &#x3D; 1 lock in share mode;update, insert，delete语句 ， 例如，假设要update一条记录，但是另一个事务已经delete这条数据并且commit了，如果不加锁就会产生冲突。所以update的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。 MVCC能否解决了幻读问题呢？有关这个问题查了很多资料,有的说能解决，有的说不能解决，也有人说能解决部分幻读场景。这里部分解决指的是能解决~~~~快照读~~~~的幻读问题，不能解决~~~~当前读~~~~的幻读问题。具体可以看下面这篇文章面试题之：MVCC能否解决幻读？https://blog.csdn.net/qq_35590091&#x2F;article&#x2F;details&#x2F;107734005先说我的结论:MVCC能解决不可重复读问题,但是不能解决幻读问题，不论是快照读和当前读都不能解决。RR级别解决幻读靠的是锁机制,而不是MVCC机制。既然网上那么多人说，MVCC解决能解决快照读下的幻读问题， 那这里通过举示例来说明,MVCC解决不了快照读的幻读问题。假设有张用户表,这张表的 id 是主键。表中一开始有4条数据。 这里是在RR级别下研究(可重复读)。 1、事务A,查询是否存在 id&#x3D;5 的记录，没有则插入，这是我们期望的正常业务逻辑。2、这个时候 事务B 新增的一条 id&#x3D;5 的记录，并提交事务。3、事务A,再去查询 id&#x3D;5 的时候,发现还是没有记录。上面的文章是这样来举例说明,事务A第一次和第二次读到的是一样的，所以认为解决了幻读。我不认为这个是解决了幻读，而是解决了不可能重复读。它保证了第一次和第二次所读到的结果是一样的。解决幻读了吗？显然没有，因为这个时候如果事务A执行一条插入操作INSERT INTO user (id, name, pwd) VALUES (5, ‘田七’, ‘fff’); 最终 事务A 提交事务，发现报错了。这就很奇怪，查的时候明明没有这条记录，但插入的时候 却告诉我 主键冲突，这就好像幻觉一样。这才是幻读问题。所以说MVCC是不能解决的，要想解决还是需要锁。这里事务A能正常的插入的前提就是其它事务不能插入id&#x3D;5并提交成功。要解决这个问题也很简单，就是事务A先获得id&#x3D;5这个排它锁。我们可以在事务A第一次查询的时候加一个排他锁select * from user where id = 5 for update那么事务B的插入动作永远属于堵塞状态，直到事务A插入成功，并提交。那么最终是事务B报主键冲突而回滚。但事务A不会因为查询的时候没有这条记录，插入失败。也就解决了幻读问题。所以说 RR级别下解决幻读问题靠的是锁机制，而不是MVCC机制。 锁 主从复制备库B跟主库A之间维持了一个长连接。主库A内部有一个线程，专门用于服务备库B的这个长连接。一个事务日志同步的完整过程是这样的： 在备库B上通过change master命令，设置主库A的IP、端口、用户名、密码，以及要从哪个位置开始请求binlog，这个位置包含文件名和日志偏移量。 在备库B上执行start slave命令，这时候备库会启动两个线程，就是图中的io_thread和sql_thread。其中io_thread负责与主库建立连接。 主库A校验完用户名、密码后，开始按照备库B传过来的位置，从本地读取binlog，发给B。 备库B拿到binlog后，写到本地文件，称为中转日志（relay log）。 sql_thread读取中转日志，解析出日志里的命令，并执行。 减少主备延迟coordinator就是原来的sql_thread, 不过现在它不再直接更新数据了，只负责读取中转日志和分发事务。真正更新日志的，变成了worker线程。而work线程的个数，就是由参数**slave_parallel_workers**决定的。","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"第80场双周赛 TP-Link","slug":"第80场 双周赛TP-Link","date":"2022-06-25T01:02:22.398Z","updated":"2022-06-25T01:02:11.322Z","comments":true,"path":"2022/06/25/第80场 双周赛TP-Link/","link":"","permalink":"http://example.com/2022/06/25/%E7%AC%AC80%E5%9C%BA%20%E5%8F%8C%E5%91%A8%E8%B5%9BTP-Link/","excerpt":"","text":"前两题略 2301. 替换字符后匹配难度困难10收藏分享切换为英文接收动态反馈给你两个字符串 s 和 sub 。同时给你一个二维字符数组 mappings ，其中 mappings[i] &#x3D; [oldi, newi] 表示你可以将 sub 中任意数目的 oldi 字符替换为 newi 。sub 中每个字符 不能 被替换超过一次。如果使用 mappings 替换 0 个或者若干个字符，可以将 sub 变成 s 的一个子字符串，请你返回 true，否则返回 false 。一个 子字符串 是字符串中连续非空的字符序列。 示例 1：输入：s &#x3D; “fool3e7bar”, sub &#x3D; “leet”, mappings &#x3D; [[“e”,”3”],[“t”,”7”],[“t”,”8”]] 输出：true 解释：将 sub 中第一个 ‘e’ 用 ‘3’ 替换，将 ‘t’ 用 ‘7’ 替换。 现在 sub &#x3D; “l3e7” ，它是 s 的子字符串，所以我们返回 true 。 思路：使用一个boolean[][] vis 数组，记录mapppings映射关系。（或者使用HashMap&lt;Character, set&gt;); 时间复杂度：O（mn), 先找到s 字符串中的起始点，再开始遍历字符串sub. 12345678910111213141516171819202122232425262728293031class Solution &#123; public boolean matchReplacement(String s, String sub, char[][] mappings) &#123; boolean[][] vis=new boolean[128][128]; for (int i = 0; i &lt; mappings.length; i++) &#123; vis[mappings[i][0]-&#x27;0&#x27;][mappings[i][1]-&#x27;0&#x27;]=true; &#125; // char start=sub.charAt(0); for (int i = 0; i &lt; s.length() &amp;&amp; i+sub.length()-1&lt;s.length(); i++) &#123; char c=s.charAt(i); if(c==start || vis[start-&#x27;0&#x27;][c-&#x27;0&#x27;])&#123; if(match(s.substring(i+1),sub.substring(1),vis))&#123; return true; &#125; &#125; &#125; return false; &#125; private boolean match(String s, String sub, boolean[][] vis)&#123; for (int i = 0; i &lt; sub.length(); i++) &#123; if(s.charAt(i)!=sub.charAt(i) &amp;&amp; !vis[sub.charAt(i)-&#x27;0&#x27;][s.charAt(i)-&#x27;0&#x27;])&#123; return false; &#125; &#125; return true; &#125; &#125; 2302. 统计得分小于 K 的子数组数目难度困难9收藏分享切换为英文接收动态反馈一个数字的 分数 定义为数组之和 乘以 数组的长度。 比方说，[1, 2, 3, 4, 5] 的分数为 (1 + 2 + 3 + 4 + 5) * 5 &#x3D; 75 。 给你一个正整数数组 nums 和一个整数 k ，请你返回 nums 中分数 **严格小于 **k 的 非空整数子数组数目。子数组 是数组中的一个连续元素序列。————&gt;滑动窗口 示例 1：输入：nums &#x3D; [2,1,4,3,5], k &#x3D; 10 输出：6 解释： 有 6 个子数组的分数小于 10 ： - [2] 分数为 2 * 1 &#x3D; 2 。 - [1] 分数为 1 * 1 &#x3D; 1 。 - [4] 分数为 4 * 1 &#x3D; 4 。 - [3] 分数为 3 * 1 &#x3D; 3 。 - [5] 分数为 5 * 1 &#x3D; 5 。 - [2,1] 分数为 (2 + 1) * 2 &#x3D; 6 。 注意，子数组 [1,4] 和 [4,3,5] 不符合要求，因为它们的分数分别为 10 和 36，但我们要求子数组的分数严格小于 10 。 思路：滑动窗口，右拉左。时间复杂度：O（n) 1234567891011121314151617181920212223class Solution &#123; public long countSubarrays(int[] nums, long k) &#123; long ans=0; long sum=0; //left和right组成的滑动窗口 for(int left=0, right=0;right&lt;nums.length;right++)&#123; sum+=nums[right]; //左边界右移 while(sum*(right-left+1)&gt;=k)&#123; sum-=nums[left]; left++; &#125; //计算当前左，右边界，满足条件的所有子数组 ans+=right-left+1; &#125; return ans; &#125;&#125;","categories":[],"tags":[{"name":"周赛","slug":"周赛","permalink":"http://example.com/tags/%E5%91%A8%E8%B5%9B/"}]},{"title":"单例模式","slug":"单例模式","date":"2022-06-23T13:25:44.106Z","updated":"2022-06-23T13:24:44.162Z","comments":true,"path":"2022/06/23/单例模式/","link":"","permalink":"http://example.com/2022/06/23/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"懒汉式——线程不安全、线程安全、DCL（锁的优化）饿汉式静态内部类枚举 应用场景：JDK中runtime类，spring里bean默认单例 1、懒汉式，线程不安全是否 Lazy 初始化：是是否多线程安全：否实现难度：易描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。 实例123456789101112public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; //public接口返回实例 public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。 2、懒汉式，线程安全是否 Lazy 初始化：是是否多线程安全：是实现难度：易描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。 实例12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125; 3、饿汉式是否 Lazy 初始化：否是否多线程安全：是，由JVM类加载机制保证。实现难度：易描述：这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。 类的加载过程：1.加载2.链接：a. 验证 b.准备（给类的静态成员变量赋默认值） c.解析3.初始化：类静态成员变量初始化 实例1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125; 4、双检锁&#x2F;双重校验锁（DCL，即 double-checked locking）JDK 版本：JDK1.5 起是否 Lazy 初始化：是是否多线程安全：是实现难度：较复杂，同步代码块描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。getInstance() 的性能对应用程序很关键。 1234567891011121314151617181920212223/** * double checked lock 懒汉式 */public class SingletonDemo &#123; //volatile禁止指令重排 private static volatile SingletonDemo instance=null; private SingletonDemo() &#123; &#125; public static SingletonDemo getInstance()&#123; //减小锁的粒度 if(instance==null)&#123; synchronized (SingletonDemo.class)&#123; //保证同步 if(instance==null)&#123; instance=new SingletonDemo(); &#125; &#125; &#125; //另外一个线程会拿到未初始化的实例 return instance; &#125;&#125; 为什么DCL要使用volatileDCL（双端检锁）机制不一定是线程安全的，原因是有指令重排的存在，加入volatile可以禁止指令重排原因是在某一个线程执行到第一次检测的时候，读取到 instance 不为null，instance的引用对象可能没有完成实例化。因为instance &#x3D; new SingletonDemo()；可以分为以下三步进行完成： memory &#x3D; allocate(); &#x2F;&#x2F; 1、分配对象内存空间 instance(memory); &#x2F;&#x2F; 2、初始化对象 instance &#x3D; memory; &#x2F;&#x2F; 3、设置instance指向刚刚分配的内存地址，此时instance !&#x3D; null 但是我们通过上面的三个步骤，能够发现，步骤2 和 步骤3之间不存在 数据依赖关系，而且无论重排前 还是重排后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。顺序的情况下，new指令申请了一块内存空间，invokespecial调用构造方法为对象进行初始化，astore_1将变量和新创建的对象关联起来。但是invokespecial和astore_1这两条指令没有关联性，所以astore_1有可能会跑到invokespecial前面执行。如图，假设两个线程，线程1执行完astore_1时(此时instance已经指向一块内存地址，不为null，但是对象还未完成初始化)，CPU切换到线程2执行if(instance&#x3D;&#x3D;null)，结果为false，于是返回了一个不完整的对象。使用volatile禁止指令重排就可以避免这种情况发生。 5、登记式&#x2F;静态内部类是否 Lazy 初始化：是是否多线程安全：是实现难度：一般描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。 123456789101112131415public class SingleTon &#123; //创建私有的构造方法 private SingleTon()&#123; &#125; //2.在类内部创建一个对象，不使用静态内部类的成员不会加载 private static class Holder&#123; private static final SingleTon instance = new SingleTon(); &#125; //3.定义一个公开的方法来获得单例对象 public static SingleTon getInstance()&#123; //静态类直接通过类调用 return Holder.instance; &#125;&#125; 6. 枚举1234567891011121314151617public enum Singleton &#123; INSTANCE; public void businessMethod() &#123; System.out.println(&quot;我是一个单例！&quot;); &#125;&#125;public class MainClass &#123; public static void main(String[] args) &#123; //调用枚举类对象 Singleton s1 = Singleton.INSTANCE; Singleton s2 = Singleton.INSTANCE; System.out.println(s1==s2); &#125;&#125; 反射机制破解单例模式（枚举除外）：通过反射拿到私有的构造器 123456789101112131415public class BreakSingleton&#123; public static void main(String[] args) throw Exception&#123; Class clazz = Class.forName(&quot;Singleton&quot;); Constructor c = clazz.getDeclaredConstructor(null); c.setAccessible(true); //构造器c.newInstance() Singleton s1 = c.newInstance(); Singleton s2 = c.newInstance(); //通过反射，得到的两个不同对象 System.out.println(s1); System.out.println(s2); &#125;&#125; 如何避免以上的漏洞： 123456789101112class Singleton&#123; private static final Singleton singleton = new Singleton(); private Singleton() &#123; //在构造器中加个逻辑判断,多次调用,抛出异常 if(instance!= null)&#123; throw new RuntimeException() &#125; &#125; public static Singleton getInstance()&#123; return singleton; &#125;&#125; 序列化，反序列化破坏序列化会通过反射调用无参数的构造方法创建一个新的对象。 1234567891011121314151617181920package com.hollis;import java.io.*;/** * Created by hollis on 16/2/5. */public class SerializableDemo1 &#123; //为了便于理解，忽略关闭流操作及删除文件操作。真正编码时千万不要忘记 //Exception直接抛出 public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //Write Obj to file ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;tempFile&quot;)); oos.writeObject(Singleton.getSingleton()); //Read Obj from file File file = new File(&quot;tempFile&quot;); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); Singleton newInstance = (Singleton) ois.readObject(); //判断是否是同一个对象 System.out.println(newInstance == Singleton.getSingleton()); &#125;&#125; isInstantiable：如果一个serializable&#x2F;externalizable的类可以在运行时被实例化，那么该方法就返回true。desc.newInstance：该方法通过反射的方式调用无参构造方法新建一个对象。 123456Object obj;try &#123; obj = desc.isInstantiable() ? desc.newInstance() : null;&#125; catch (Exception ex) &#123; throw (IOException) new InvalidClassException(desc.forClass().getName(),&quot;unable to create instance&quot;).initCause(ex);&#125; 如何避免实现序列化单例模式的漏洞：先给出解决方案，然后再具体分析原理：只要在Singleton类中定义readResolve就可以解决该问题：应用：currency类 12345678910111213141516171819202122232425package com.hollis;import java.io.Serializable;/** * Created by hollis on 16/2/5. * 使用双重校验锁方式实现单例 */public class Singleton implements Serializable&#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; //返回单例 private Object readResolve() &#123; return singleton; &#125;&#125; 123456789101112if (obj != null &amp;&amp; handles.lookupException(passHandle) == null &amp;&amp; desc.hasReadResolveMethod()) &#123; Object rep = desc.invokeReadResolve(obj); if (unshared &amp;&amp; rep.getClass().isArray()) &#123; rep = cloneArray(rep); &#125; if (rep != obj) &#123; handles.setObject(passHandle, obj = rep); &#125; &#125; hasReadResolveMethod:如果实现了serializable 或者 externalizable接口的类中包含readResolve则返回trueinvokeReadResolve:通过反射的方式调用要被反序列化的类的readResolve方法。所以，原理也就清楚了，主要在Singleton中定义readResolve方法，并在该方法中指定要返回的对象的生成策略，就可以防止单例被破坏。","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"并查集与拓扑排序","slug":"并查集和拓扑排序","date":"2022-06-22T07:26:15.151Z","updated":"2022-07-05T17:12:33.721Z","comments":true,"path":"2022/06/22/并查集和拓扑排序/","link":"","permalink":"http://example.com/2022/06/22/%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%92%8C%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","excerpt":"","text":"并查集：无向图，只有边的概念。UnionFind:拓扑排序：有向图，点有入度和出度。从入度为0的点开始排序（没有前置条件） 是否有环无向图：并查集，要加入的边，两边的点已经在同一集合了。有向图：拓扑排序，看是否所有的点的入度都可以消除为0。使用一个栈，保存所有入度&#x3D;0的点，可以加入结果集，并且用set&#x2F;list保存了当前点的下一个点，由此删除下一个点的入度。如图所示有向图，无环，可以生成一个拓扑排序示例 1：输入：“1-&gt;2,2-&gt;3,3-&gt;1”输出：true示例 2：输入：“1-&gt;4,2-&gt;5,3-&gt;6,3-&gt;7,4-&gt;8,5-&gt;8,5-&gt;9,6-&gt;9,6-&gt;11,7-&gt;11,8-&gt;12,9-&gt;12,9-&gt;13,10-&gt;13,10-&gt;14,11-&gt;10,11-&gt;14”输出：false示例 3：输入：“1-&gt;4,2-&gt;5,3-&gt;6,3-&gt;7,4-&gt;8,5-&gt;8,5-&gt;9,6-&gt;9,6-&gt;11,7-&gt;11,8-&gt;12,9-&gt;12,9-&gt;13,10-&gt;6,10-&gt;13,10-&gt;14,11-&gt;10,11-&gt;14”输出：true解释:存在环线:6-&gt;11,11-&gt;10,10-&gt;6提示: 0 &lt; 节点数 &lt; 100123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import org.junit.Test;import java.util.ArrayDeque;import java.util.ArrayList;import java.util.HashSet;public class LeetCode &#123; @Test public void test() &#123; Solution so = new Solution(); System.out.println(so.hasCycle(&quot;1-&gt;4,2-&gt;5,3-&gt;6,3-&gt;7,4-&gt;8,5-&gt;8,5-&gt;9,6-&gt;9,6-&gt;11,7-&gt;11,8-&gt;12,9-&gt;12,9-&gt;13,10-&gt;6,10-&gt;13,10-&gt;14,11-&gt;10,11-&gt;14&quot;)); &#125; class Solution &#123; public boolean hasCycle(String graph) &#123; String[] split = graph.split(&quot;,&quot;); int n = split.length; //存所有节点 HashSet&lt;Integer&gt; node = new HashSet&lt;&gt;(); //入度 int[] inpoint = new int[2 * n + 1]; boolean[] visited = new boolean[2 * n + 1]; //next step,数组 HashSet&lt;Integer&gt;[] list = new HashSet[2 * n + 1]; for (int i = 0; i &lt; n; i++) &#123; String[] strings = new String[2]; strings = split[i].split(&quot;-&gt;&quot;); int u = Integer.parseInt(strings[0]); int v = Integer.parseInt(strings[1]); node.add(u); node.add(v); visited[v] = true; visited[u] = true; //入度 inpoint[v]++; if (list[u] == null) &#123; list[u] = new HashSet&lt;&gt;(); &#125; //邻接表 list[u].add(v); &#125; ArrayDeque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;(2 * n + 1); for (int i = 0; i &lt; 2 * n + 1; i++) &#123; if (visited[i] &amp;&amp; inpoint[i] == 0) &#123; stack.add(i); &#125; &#125; //所有入度可减小为0的点，可排序的点 ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;(); while (!stack.isEmpty()) &#123; int cur = stack.poll(); integers.add(cur); if (list[cur] != null) &#123; for (Integer i : list[cur]) &#123; inpoint[i]--; if (inpoint[i] == 0) &#123; stack.push(i); &#125; &#125; &#125; &#125; return integers.size() &lt; node.size(); &#125; &#125;&#125; 无向图是否存在环join的时候，利用find进行路径压缩 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123; /** 并查集（union-find, 或disjoint set）可以动态地连通两个点，并且可以非常快速地判断两个点是否连通。 初始化：所有点的母节点为自己 每次要连接节点i 和j 时，我们可以将i 的父亲标为j； 每次要查询两个节点是否相连时，我们可以查找i 和j 的祖先是否最终为同一个人。 1.find：找到祖先 2.same:是否在同一个集合，同一根节点 3.join,将两个节点连在同一节点 */ private int n; private int[] father; public Solution()&#123; n=1005; father=new int[n]; for(int i=0;i&lt;n;i++)&#123; father[i]=i;//父节点 &#125; &#125; //找到祖先 public int find(int u)&#123; if(u==father[u]) return u;//base case:是根 father[u]=find(father[u]);//迭代找到祖先 return father[u]; &#125; //是否在同一集合，同一个根节点，就在同一集合 public boolean same(int u,int v)&#123; u=find(u); v=find(v); return u==v; &#125; //v-&gt;u 这条边加入并查集，调用find,进行路径压缩，直接与连在根节点上 public void join(int u,int v)&#123; u=find(u); v=find(v); if(u==v) return;//已经存在 father[v]=u; &#125; //遍历边，如果已经在同一集合，结果又有新边，返回这条新边 //在并查集加入新边 //solution不用自己new public int[] findRedundantConnection(int[][] edges) &#123; for(int[] line:edges)&#123; if(same(line[0],line[1])) return line; else join(line[0],line[1]); &#125; return new int[]&#123;&#125;; &#125;&#125;","categories":[],"tags":[{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"494.目标和","slug":"494 目标和","date":"2022-06-20T10:20:21.777Z","updated":"2022-06-20T11:37:15.088Z","comments":true,"path":"2022/06/20/494 目标和/","link":"","permalink":"http://example.com/2022/06/20/494%20%E7%9B%AE%E6%A0%87%E5%92%8C/","excerpt":"","text":"494. 目标和难度中等1166 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 &#39;+&#39; 或 &#39;-&#39; ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 &#39;+&#39; ，在 1 之前添加 &#39;-&#39; ，然后串联起来得到表达式 &quot;+2-1&quot; 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 12345678输入：nums = [1,1,1,1,1], target = 3输出：5解释：一共有 5 种方法让最终目标和为 3 。-1 + 1 + 1 + 1 + 1 = 3+1 - 1 + 1 + 1 + 1 = 3+1 + 1 - 1 + 1 + 1 = 3+1 + 1 + 1 - 1 + 1 = 3+1 + 1 + 1 + 1 - 1 = 3 123456789101112131415161718192021222324252627class Solution &#123; //0,1背包问题 //找到子集为4的集合 public int findTargetSumWays(int[] nums, int target) &#123; int n=nums.length; int sum=0; for(int num:nums)&#123; sum+=num; &#125; int weight= (sum+target)&gt;&gt;1; if((sum+target)%2==1 || weight&lt;0)&#123; return 0; &#125; int[] dp=new int[weight+1]; dp[0]=1;//初始化 for(int num:nums)&#123;//枚举i的质量 for(int j=weight;j&gt;=num;j--)&#123;//循环背包，-- dp[j]+=dp[j-num]; &#125; &#125; return dp[weight]; &#125;&#125;","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"494.目标和","slug":"416 背包问题","date":"2022-06-20T10:20:21.775Z","updated":"2022-06-20T11:37:39.775Z","comments":true,"path":"2022/06/20/416 背包问题/","link":"","permalink":"http://example.com/2022/06/20/416%20%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/","excerpt":"","text":"416. 分割等和子集难度中等1213 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 123输入：nums = [1,5,11,5]输出：true解释：数组可以分割成 [1, 5, 5] 和 [11] 。 dp[ i] [j ]:长度为i的数组，可选可不选（0，1），他们的和能组成j,是true还是false 边界条件：dp [] [0]&#x3D;true,这样状态转移方程中dp[i-1] [j-nums[i]]能等于true. 也可使用记忆化深度优先搜索。 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum=0; for(int element:nums) &#123; sum+=element; &#125; if(sum%2==1) &#123; return false; &#125; return dfs(nums,0,0,sum,new HashMap&lt;String,Boolean&gt;()); &#125; public boolean dfs(int[]nums,int index,int sum,int target, HashMap&lt;String,Boolean&gt; map) &#123; //map.put(index+&quot;&quot;+sum,); if(map.containsKey(index+&quot;&quot;+sum)) &#123; return map.get(index+&quot;&quot;+sum);//在其他分支中已经算过的，相同的层次，相同的sum &#125; if(sum*2==target) &#123; return true; &#125; if(sum&gt;target/2 || index&gt;=nums.length) &#123; return false; &#125; boolean partition= dfs(nums,index+1,sum+nums[index],target,map)||dfs(nums,index+1,sum,target,map); map.put(index+&quot;&quot;+sum, partition); return partition; &#125;&#125; dp:空间压缩 123456789101112131415161718192021222324252627282930class Solution &#123; public boolean canPartition(int[] nums) &#123; int sum=0; for(int element:nums) &#123; sum+=element; &#125; if(sum%2==1) &#123; return false; &#125; int target=sum/2; int n=nums.length; boolean[]dp=new boolean[target+1]; dp[0]=true; for(int i=1;i&lt;n+1;i++)&#123;//每一个i循环填充一个dp数组 for(int j=target;j&gt;0;j--) &#123;//倒序遍历，取得上一行（i-1)数值 if(j&gt;=nums[i-1]) dp[j]=dp[j]||dp[j-nums[i-1]]; else &#123; dp[j]=dp[j]; &#125; &#125; &#125; return dp[target]; &#125; &#125; 因为j-nums[i]&lt;j, 所以倒序。若按照从左往右的顺序进行正向遍历，则dp[j-w] 的值在遍历到j 之前就已经被更新成物品i 的值了。","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"312. 戳气球","slug":"312 戳气球","date":"2022-06-20T10:20:21.774Z","updated":"2022-06-20T11:37:58.409Z","comments":true,"path":"2022/06/20/312 戳气球/","link":"","permalink":"http://example.com/2022/06/20/312%20%E6%88%B3%E6%B0%94%E7%90%83/","excerpt":"","text":"312. 戳气球难度困难972 有 n 个气球，编号为0 到 n - 1，每个气球上都标有一个数字，这些数字存在数组 nums 中。 现在要求你戳破所有的气球。戳破第 i 个气球，你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币。 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号。如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球。 求所能获得硬币的最大数量。 示例 1： 12345输入：nums = [3,1,5,8]输出：167解释：nums = [3,1,5,8] --&gt; [3,5,8] --&gt; [3,8] --&gt; [8] --&gt; []coins = 3*1*5 + 3*5*8 + 1*3*8 + 1*8*1 = 167 思路：如何找子问题（备忘录）存起来 123456789101112131415161718192021222324252627282930313233343536/** *动态规划自底向上 * * 最后一个爆破的气球可以把左右区间区分开，他们之间没有关联（不会相乘），由此将这个问题分为两个子问题 * dp[i][j]:在i到j之间能得到的最大值，不包括i,j * 逆向思考：k是最后一个爆破的气球，在(i,j)之间遍历k,取最大值 * */class Solution &#123; public int maxCoins(int[] nums) &#123; int n=nums.length; int[] tmp=new int[n+2]; int[][] dp=new int[n+2][n+2]; System.arraycopy(nums,0,tmp,1,n); tmp[0]=1; tmp[n+1]=1; for (int i =n-1; i &gt;=0; i--) &#123;//开区间(i,j) for (int j = i+2; j &lt;=n+1 ; j++) &#123; for (int k = i+1; k &lt;j; k++) &#123; dp[i][j]=Math.max(dp[i][j],dp[i][k]+dp[k][j]+tmp[k]*tmp[i]*tmp[j]); //dp[i][k]和dp[k][j]中j&gt;i+1, // 同时因为k&gt;i,所以i要从大到小遍历 &#125; &#125; &#125; return dp[0][n+1]; &#125;&#125;","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"279.完全平方数","slug":"279 分割类问题","date":"2022-06-20T10:20:21.772Z","updated":"2022-06-20T11:38:39.996Z","comments":true,"path":"2022/06/20/279 分割类问题/","link":"","permalink":"http://example.com/2022/06/20/279%20%E5%88%86%E5%89%B2%E7%B1%BB%E9%97%AE%E9%A2%98/","excerpt":"","text":"279. 完全平方数难度中等1288 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 123输入：n = 12输出：3 解释：12 = 4 + 4 + 4 示例 2： 123输入：n = 13输出：2解释：13 = 4 + 9 提示： 1 &lt;= n &lt;= 104 题解：","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"213. 打家劫舍 II","slug":"213 打家劫舍II","date":"2022-06-20T10:20:21.769Z","updated":"2022-06-20T11:39:30.274Z","comments":true,"path":"2022/06/20/213 打家劫舍II/","link":"","permalink":"http://example.com/2022/06/20/213%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII/","excerpt":"","text":"213. 打家劫舍 II难度中等1025 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 123输入：nums = [2,3,2]输出：3解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 12345678910111213141516171819202122232425262728293031class Solution &#123; /** 环形导致的bug点在于，可能导致第一家和最后一家都偷了。 所以考虑不偷第一家，和不偷最后一家。 不偷，即初始化为0。 这两种情况中肯定有一种是最优解。找到其最大值，就是最优解。 */ public int rob(int[] nums) &#123; int n=nums.length; int[] dp=new int[n]; if(n==1) return nums[0]; if(n==2) return Math.max(nums[0],nums[1]); dp[0]=0;//不偷0 dp[1]=nums[1]; for(int i=2;i&lt;=n-1;i++)&#123;//不偷第一家[1,n-1] dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);//不偷，偷 &#125; int[] dp2=new int[n]; dp2[n-1]=0;//不偷n-1 dp2[n-2]=nums[n-2]; for(int i=n-3;i&gt;=0;i--)&#123;//不偷最后一家[0,n-2] dp2[i]=Math.max(dp2[i+1],dp2[i+2]+nums[i]); &#125; return Math.max(dp[n-1],dp2[0]); &#125; &#125;","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"198.打家劫舍","slug":"198 打家劫舍I","date":"2022-06-20T10:20:21.768Z","updated":"2022-06-20T11:40:30.389Z","comments":true,"path":"2022/06/20/198 打家劫舍I/","link":"","permalink":"http://example.com/2022/06/20/198%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DI/","excerpt":"","text":"定义子问题 写出子问题的递推关系 画图：子结构 思路：动态规划。 定义子问题——偷K间房屋能偷到的最大金额: f(K) 状态转移方程——第K间房屋只有两种选择，偷或者不偷。f(K)&#x3D;max{nums[K-1]+f(K-2),f(K-1)} 边界条件：没有房屋&amp;只有一间房屋 TC:O(N) SC:O(N) 123456789101112131415class Solution &#123; public int rob(int[] nums) &#123; if(nums==null||nums.length==0)&#123; return -1; &#125; int N=nums.length; int[] dp= new int[N+1]; dp[0]=0; dp[1]=nums[0]; for(int i=2;i&lt;=N;i++)&#123; dp[i]=Math.max(dp[i-1],nums[i-1]+dp[i-2]);//自底向上，dp[i]：偷前i间最大金额 &#125; return dp[N]; &#125;&#125;","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]},{"title":"2226.每个小孩最多能分多少糖果","slug":"2226 分糖果","date":"2022-06-20T10:13:13.789Z","updated":"2022-06-20T11:31:52.346Z","comments":true,"path":"2022/06/20/2226 分糖果/","link":"","permalink":"http://example.com/2022/06/20/2226%20%E5%88%86%E7%B3%96%E6%9E%9C/","excerpt":"","text":"2226. 每个小孩最多能分到多少糖果难度中等18 给你一个 下标从 0 开始 的整数数组 candies 。数组中的每个元素表示大小为 candies[i] 的一堆糖果。你可以将每堆糖果分成任意数量的 子堆 ，但 无法 再将两堆合并到一起。 另给你一个整数 k 。你需要将这些糖果分配给 k 个小孩，使每个小孩分到 相同 数量的糖果。每个小孩可以拿走 至多一堆 糖果，有些糖果可能会不被分配。 返回每个小孩可以拿走的 最大糖果数目 。 1234567891011121314151617181920class Solution &#123; public int maximumCandies(int[] candies, long k) &#123; long max=(long)1e7; // int min=candies[0]; long left=-1; long right=max+1; while(left+1!=right)&#123;// long mid=left+(right-left)/2; long count=0; if(mid==0) return 0; for(int num:candies)&#123; count+=num/mid; &#125; if(count&lt;k) right=mid; else left=mid;足条件的最大值 &#125; return (int)left;//返回Left &#125;&#125;","categories":[],"tags":[{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]}],"categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"周赛","slug":"周赛","permalink":"http://example.com/tags/%E5%91%A8%E8%B5%9B/"},{"name":"设计模式","slug":"设计模式","permalink":"http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"算法与数据结构","slug":"算法与数据结构","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"力扣","slug":"力扣","permalink":"http://example.com/tags/%E5%8A%9B%E6%89%A3/"}]}